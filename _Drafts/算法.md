---
tags:
  - Knowledge
aliases:
  - Algorithm
---
## 排序
### 堆排序
一个数组可以看作一个二叉树，下标0处为其根节点，则对于任意节点`i`：
- 其父节点为`i // 2`；
- 其左孩子为`2*i + 1`；
- 其右孩子为`2*i + 2`。

> [!definition] 堆排序 (Heap Sort)
> 大顶堆即一个子节点大于父节点的二叉树，小顶堆反之。若欲由小到大排序，则需要构造一个大顶堆。
> 1. 将一个无序数组按下标顺序依次检查其与父节点的大小关系，若大于其父节点，则与父节点交换位置，直到不再大于其父节点；
> 2. 当检查完所有节点，我们即得到了一个大顶堆；
> 3. 此时将树顶端的数与最后一个数交换，最大的数即已经排好了顺序，将其固定，并让顶端的数下沉，继续维持大顶堆；
> 4. 再将顶端的数与倒数第二个数交换，以此类推，直到所有数都被固定。

堆排序的时间复杂度是$O(n\log n)$，额外空间复杂度是$O(1)$，是不稳定排序。
## 分治法
> [!definition] 分治法 (Divide and Conquer)
> 将一个问题逐层拆分成子问题，分别解决所有的子问题，再将子问题逐层合并成原问题的思想。

在分治法中常通过主定理来求得时间复杂度。

> [!theorem] 主定理 (Master Theorem)
> 若$T(n)=aT\left(\frac{n}{b}\right)+O\left(n^d\right)$，则有
> $$
> T(n)=
> \left\{\begin{aligned}
> & O\left(n^d\right) & ,a<b^d \\
> & O\left(n^{\log_ba}\right) & ,a>b^d \\
> & O\left(n^d\log n\right) & ,a=b^d
> \end{aligned}\right.
> $$

> [!proof] 
> 一步步展开下式：
> $$
> \begin{aligned}
> T(n)&=aT\left( \frac{n}{b} \right)+f(n)\\
> &=a^2T\left( \frac{n}{b^2} \right)+af\left( \frac{n}{b} \right)+f(n)\\
> &=\cdots\\
> &=a^{k}()
> \end{aligned}
> $$
> 对于上式，我们进行分类讨论：
> 1. 若$f(n)<n^{\log\frac{a}{b}}$，
> 证明即求通项公式。注*：$x^{\log y}=y^{\log x}$。

> ![[DQ.png|475]] #Missing 
1. 归并排序（Merge Sort）的想法及实现，$O(\log n)$。\\

2. 寻找第k大的数的随机算法：随机找一个pivot，将其与所有数比较，分成“>”“=”“<”三组。最快$O(n)$，最慢$O(n^2)$。

  

## 图算法
### DFS
#### 基本概念
> [!definition] 深度优先搜索 (Depth First Search, DFS)
> 遍历到一个节点时，如果其下游还有没有被遍历到的节点，则向此节点继续遍历下去；若其下游节点已经全部被遍历过，则回溯到其上游的节点。

DFS时间复杂度为$O(|E|+|V|)$。

#### 寻找强连通分量
可以用Tarjan算法区分开一个有向图中不同的[[图论#^fb6925|强连通分量]]。
> [!definition] Tarjan算法 (Tarjan's Algorithm)
> 我们定义：
> - $DFN(u)$为节点$u$被遍历的次序编号；
> - $LOW(u)$为从节点$u$能够返回到的节点的最小的次序编号。
> 那么算法如下：
> 1. 首次遍历$u$时，$LOW(u)=DFN(u)$，并将$u$入栈；
> 2. 访问$u$的相邻点$v$，有以下情况：
> 	1. $v$首次被遍历，对$v$进行DFS，回溯时有$LOW(u)=\min(LOW(u),LOW(v))$；
> 	2. 若$v$已经被遍历且在栈中，有$LOW(u)=\min(DFN(v),LOW(u))$；
> 	3. 若$v$已经被遍历且不在栈中，说明$v$所在强连通分量已经被处理了，这里不做操作。
> 3. 遍历完$u$的所有相邻点后，如果$LOW(u)=DFN(u)$，则$u$及其以上的所有节点都出栈。
> 
> > [!caution] 
> > 第二步的第二种情况下，由于更新$LOW(u)$用的是$\min(DFN(v),LOW(u))$，而不是$\min(LOW(v),LOW(u))$，所以最终的$LOW(u)$并不一定是节点$u$能够返回到的节点的最小的次序编号；但因为最后区分其属于哪个强连通分量是靠出栈的批次，而不是看$LOW$值，因此并不影响结果。

### BFS
#### 基本概念
> [!definition] 广度优先搜索 (Breadth First Search, BFS)
> 遍历到一个节点$u$时，先遍历与此节点相邻的节点$v$，然后再按同样的方式遍历$v$的所有相邻节点。

BFS时间复杂度：$O(|E|+|V|)$
#### 拓扑排序
> [!definition] 拓扑排序 (Topological Sorting)
> 对于一个[[图论#^a5cf02|DAG]]，将其所有的节点排成一个序列，若序列满足以下条件，此序列即为一个拓扑排序：
> - 每个节点出现且只出现一次；
> - 对于图中的任何一条边$u\to v$，$u$都排在$v$之前。

我们可以通过Kahn算法得到拓扑排序。

> [!definition] Kahn算法 (Kahn's Algorithm)
> 1. 计算DAG中的所有节点的入度，并将所有入度为零的节点入队；
> 2. 出队一个节点，遍历其所有的相邻节点，每遍历到一个节点就将此节点的入度减一，再将所有入度为零的节点入队；
> 3. 当队列为空时，节点的出队顺序即为拓扑排序的顺序。

#### 判断是否有环
对一个有向图执行Kahn算法，当队列为空时，若仍有节点未入队，此图中即有环；若所有节点都已入队，则此图为DAG。
#### 正权图最短路径
#Missing 
> [!definition] Dijkstra算法
> 即用BFS更新节点距离；时间复杂度为$O(|E|+|V|\log|V|)$；

^5c9f93

应用：正权图找最短路径。

4. Bellman-Ford算法松弛每条边来更新节点；时间复杂度为$O(|E|\cdot|V|)$；应用：负权图找最短路径、判断负环（循环$|V|$次看是否依然有节点更新，因为最短路径最长也就$|V|-1$条边）。

  

## 贪心算法
1. 基本思想：\\

选择一种局部最优的策略进行算法设计；用induction思想进行正确性分析。

参考思路：\\

归纳法：尝试证明每次决策都是某个最优解的子集，如证明Kruskal每次选完边仍然是某个最想生成树的子集。\\

反证法：假设某次决策不再是某个最优解的子集，通过交换等方法构造性地导出矛盾。

  

\textbf{Dynamic Programming}\par

1. DP算法基本设计思想：思考问题的基本递归解法；总结递归解法过程中所需的状态；将递归解法写成状态转移的方式；检查状态转移是否构成DAG；通过归纳法证明DP算法的正确性：关键说明转移这一步为什么成立（对应归纳证明那一步）。\\

参考案例：最长上升子序列、编辑距离、背包问题。\\

2. 优化DP（优先队列）：将又老又菜（没有竞争力）的保存状态踢出考虑范围。例如最长上升子序列优化：图中有2-2在，5-2就不可能被之后选中，因此可将优先队列2位置的5改为2。

\begin{center}

\includegraphics[width=0.5\textwidth]{figure/DP.png}

\end{center}

3. Floyd-Warshall算法：给$|V|$个点随机编号，$dist(k,i,j)$代表只允许经过前$k$个点的$v_i\to v_j$的最短路径长度，$dist(k,i,j)=\min\{dist(k-1,i,j),dist(k-1,i,k)+dist(k-1,k,j)\}$。因为$v_i\to v_j$的最短路径若不经过第$k$个点，$dist(k,i,j)$则可以由$dist(k-1,i,j)$得来；若经过第$k$个点，$v_k$即可把此最短路径分为$v_i\to v_k$与$v_k\to v_j$两条最短路径，此时$dist(k,i,j)=dist(k-1,i,k)+dist(k-1,k,j)$。所需三维列表边长均为$|V|$，所以时间复杂度为$O(|V|^3)$。\\

4. TSP问题：无向图中每条边都有其花费和报酬，从点$s$出发，经过所有的点再回到$s$，求最大利润。时间复杂度$O(|V|^2\cdot2^{|V|})$。

  

\textbf{Max-Flow}\par

1. Ford-Fulkerson算法：\\

基本思路：作residual network，边权等于每条边上剩余流量；找到$s\to t$的一条路径$p$，取其最窄处为最小流量，$p$上每条边减去此流量，反向边加上此流量，得到更新后的图；反复迭代到找不到$p$，程序停止。\\

该算法在无理数情况下无法保证终止；在有理数/整数情况下为$O(|E|\cdot f_{max})$，无法保证多项式时间复杂度。\\

2. Edmonds-Karp算法：\\

用BFS寻找$s\to t$的最短路径的方式来执行Ford-Fulkerson，保证了每次迭代时$s\to t$距离的单调性，从而实现多项式时间复杂度$O(|V|\cdot|E|^2)$（每次$O(|E|)$复杂度，迭代$|E|\cdot|V|$轮）。\\

3. Dinic算法：\\

用BFS建立level graph，在其中用DFS寻找阻塞流，最多找$O(|E|)$次，每次花费$O(|V|)$，因此此次迭代共需$O(|E|\cdot|V|)$。反复此操作，最多重复$|V|$次。整个算法共需$O(|V|^2\cdot|E|)$。\\

对于边权均为1的图，其每次迭代需要$O(|E|)$次，因为DFS只要经过某条边，其就可被消去。而后令其迭代$2|V|^\frac{2}{3}$或$|E|^\frac{1}{2}$次，可证明只需同样数量级的迭代即可完成。\\

4. Integrality Theorem: 如果所有的capacity是整数，那么一定存在整数最大流（整数流是指每条边上的流量为整数）。$\bigstar$是得分点，记得写上。\\

5. Max-Flow-Min-Cut Theorem：一个图的最大流等于最小割。\\

6. 最大流问题的应用：\\

Assignment相关问题、二分图的最大匹配 \\

\includegraphics[height=0.15\textwidth]{figure/MF1.png}

\includegraphics[height=0.2\textwidth]{figure/MF2.png}

\includegraphics[height=0.2\textwidth]{figure/MF3.png}

  

\textbf{Linear Programming}\par

1. 单纯形法：沿可行域的边去找最优点，时间复杂度非多项式。\\

2. 对偶问题的转化：

\begin{center}

\includegraphics[width=0.5\textwidth]{figure/LP1.png}

\end{center}

3. 若上式中$A$是totally unimodular矩阵，且$b$为全整数向量，则x有整数最优解；同理，$A$为totally unimodular矩阵，$c$为全整数向量，则y有整数最优解。\\

4. 运用Strong Duality Theorem证明Max-Flow-Min-Cut Theorem。

\begin{center}

\includegraphics[width=0.8\textwidth]{figure/LP2.png}

\end{center}

  

\textbf{Basic Complexity Theory}\par

1. 证明NP：在多项式时间内可以验证。\\

2. 证明“一个问题是另一个问题的特殊情况”reduction来证明NP-hard。\\

3. 由1、2证明NP-complete。\\

4. 常见NP-complete问题：

\begin{center}

\includegraphics[width=0.5\textwidth]{figure/NP1.png}

\end{center}