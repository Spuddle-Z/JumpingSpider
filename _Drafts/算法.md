---
tags:
  - Knowledge
  - Missing
aliases:
  - Algorithm
---
## Divide and Conquer
1. **主定理(Master Theorem)**：在分治法中常通过主定理来求得时间复杂度。若$T(n)=aT\left(\frac{n}{b}\right)+O\left(n^d\right)$，则
	$$T(n)=
	\left\{\begin{aligned}
	& O\left(n^d\right) & ,a<b^d \\
	& O\left(n^{\log_ba}\right) & ,a>b^d \\
	& O\left(n^d\log n\right) & ,a=b^d
	\end{aligned}\right.
	$$
	 证明即求通项公式。注*：$x^{\log y}=y^{\log x}$。
	![[DQ.png|475]]
2. 归并排序（Merge Sort）的想法及实现，$O(\log n)$。\\

3. 寻找第k大的数的随机算法：随机找一个pivot，将其与所有数比较，分成“>”“=”“<”三组。最快$O(n)$，最慢$O(n^2)$。

  

## 图算法
### DFS
DFS时间复杂度：$O(|E|+|V|)$；
应用：判断图中是否有环、拓扑排序、寻找强连通分量。
### BFS
BFS时间复杂度：$O(|E|+|V|)$；应用：无权图上用求最短路径。
> [!definition] Dijkstra算法
> 即用BFS更新节点距离；时间复杂度为$O(|E|+|V|\log|V|)$；

应用：正权图找最短路径。

4. Bellman-Ford算法松弛每条边来更新节点；时间复杂度为$O(|E|\cdot|V|)$；应用：负权图找最短路径、判断负环（循环$|V|$次看是否依然有节点更新，因为最短路径最长也就$|V|-1$条边）。

  

## 贪心算法
1. 基本思想：\\

选择一种局部最优的策略进行算法设计；用induction思想进行正确性分析。

参考思路：\\

归纳法：尝试证明每次决策都是某个最优解的子集，如证明Kruskal每次选完边仍然是某个最想生成树的子集。\\

反证法：假设某次决策不再是某个最优解的子集，通过交换等方法构造性地导出矛盾。

  

\textbf{Dynamic Programming}\par

1. DP算法基本设计思想：思考问题的基本递归解法；总结递归解法过程中所需的状态；将递归解法写成状态转移的方式；检查状态转移是否构成DAG；通过归纳法证明DP算法的正确性：关键说明转移这一步为什么成立（对应归纳证明那一步）。\\

参考案例：最长上升子序列、编辑距离、背包问题。\\

2. 优化DP（优先队列）：将又老又菜（没有竞争力）的保存状态踢出考虑范围。例如最长上升子序列优化：图中有2-2在，5-2就不可能被之后选中，因此可将优先队列2位置的5改为2。

\begin{center}

\includegraphics[width=0.5\textwidth]{figure/DP.png}

\end{center}

3. Floyd-Warshall算法：给$|V|$个点随机编号，$dist(k,i,j)$代表只允许经过前$k$个点的$v_i\to v_j$的最短路径长度，$dist(k,i,j)=\min\{dist(k-1,i,j),dist(k-1,i,k)+dist(k-1,k,j)\}$。因为$v_i\to v_j$的最短路径若不经过第$k$个点，$dist(k,i,j)$则可以由$dist(k-1,i,j)$得来；若经过第$k$个点，$v_k$即可把此最短路径分为$v_i\to v_k$与$v_k\to v_j$两条最短路径，此时$dist(k,i,j)=dist(k-1,i,k)+dist(k-1,k,j)$。所需三维列表边长均为$|V|$，所以时间复杂度为$O(|V|^3)$。\\

4. TSP问题：无向图中每条边都有其花费和报酬，从点$s$出发，经过所有的点再回到$s$，求最大利润。时间复杂度$O(|V|^2\cdot2^{|V|})$。

  

\textbf{Max-Flow}\par

1. Ford-Fulkerson算法：\\

基本思路：作residual network，边权等于每条边上剩余流量；找到$s\to t$的一条路径$p$，取其最窄处为最小流量，$p$上每条边减去此流量，反向边加上此流量，得到更新后的图；反复迭代到找不到$p$，程序停止。\\

该算法在无理数情况下无法保证终止；在有理数/整数情况下为$O(|E|\cdot f_{max})$，无法保证多项式时间复杂度。\\

2. Edmonds-Karp算法：\\

用BFS寻找$s\to t$的最短路径的方式来执行Ford-Fulkerson，保证了每次迭代时$s\to t$距离的单调性，从而实现多项式时间复杂度$O(|V|\cdot|E|^2)$（每次$O(|E|)$复杂度，迭代$|E|\cdot|V|$轮）。\\

3. Dinic算法：\\

用BFS建立level graph，在其中用DFS寻找阻塞流，最多找$O(|E|)$次，每次花费$O(|V|)$，因此此次迭代共需$O(|E|\cdot|V|)$。反复此操作，最多重复$|V|$次。整个算法共需$O(|V|^2\cdot|E|)$。\\

对于边权均为1的图，其每次迭代需要$O(|E|)$次，因为DFS只要经过某条边，其就可被消去。而后令其迭代$2|V|^\frac{2}{3}$或$|E|^\frac{1}{2}$次，可证明只需同样数量级的迭代即可完成。\\

4. Integrality Theorem: 如果所有的capacity是整数，那么一定存在整数最大流（整数流是指每条边上的流量为整数）。$\bigstar$是得分点，记得写上。\\

5. Max-Flow-Min-Cut Theorem：一个图的最大流等于最小割。\\

6. 最大流问题的应用：\\

Assignment相关问题、二分图的最大匹配 \\

\includegraphics[height=0.15\textwidth]{figure/MF1.png}

\includegraphics[height=0.2\textwidth]{figure/MF2.png}

\includegraphics[height=0.2\textwidth]{figure/MF3.png}

  

\textbf{Linear Programming}\par

1. 单纯形法：沿可行域的边去找最优点，时间复杂度非多项式。\\

2. 对偶问题的转化：

\begin{center}

\includegraphics[width=0.5\textwidth]{figure/LP1.png}

\end{center}

3. 若上式中$A$是totally unimodular矩阵，且$b$为全整数向量，则x有整数最优解；同理，$A$为totally unimodular矩阵，$c$为全整数向量，则y有整数最优解。\\

4. 运用Strong Duality Theorem证明Max-Flow-Min-Cut Theorem。

\begin{center}

\includegraphics[width=0.8\textwidth]{figure/LP2.png}

\end{center}

  

\textbf{Basic Complexity Theory}\par

1. 证明NP：在多项式时间内可以验证。\\

2. 证明“一个问题是另一个问题的特殊情况”reduction来证明NP-hard。\\

3. 由1、2证明NP-complete。\\

4. 常见NP-complete问题：

\begin{center}

\includegraphics[width=0.5\textwidth]{figure/NP1.png}

\end{center}