## 8.1
- [ ] 写论文

### 论文片段
此外，三种近似算法都涉及超参数的选择。
- 在ACH算法中，重要性差值阈值
- Distance Oracle算法中，$k$代表了对节点集的分层深度，更大的$k$意味着更高的精度与更长的处理时间。
- 在ALT算法中，landmark的数量会影响算法的结果，更多的landmark意味着更长的预处理与查询时间，同时意味着更加准确的距离。具体的landmark数量选择为Boston-，Porto-，Beijing-。

### 超参数选择
#### ALT
最终选择
- Time

| Landmark | Boston         | Porto           | Jinan          | Beijing         |
| -------- | -------------- | --------------- | -------------- | --------------- |
| 8        | $0.63\pm0.02$* | $5.32\pm0.07$   | $22.65\pm0.19$ | $29.83\pm0.11$  |
| 16       | $1.18\pm0.02$  | $10.28\pm0.09$  |                | $74.22\pm0.23$  |
| 32       | $2.54\pm0.26$  | $19.97\pm0.28$* |                | $146.35\pm0.84$ |
| 64       | -              | $38.38\pm0.27$  |                | $288.20\pm0.60$ |
| 128      | -              | $77.06\pm1.10$  |                | $579.15\pm4.73$ |
- MRE

| Landmark | Boston  | Porto   | Jinan  | Beijing |
| -------- | ------- | ------- | ------ | ------- |
| 8        | $0.21$* | $0.18$  | $0.08$ | $0.11$  |
| 16       | $0.19$  | $0.14$  |        | $0.08$  |
| 32       | $0.17$  | $0.10$* |        | $0.07$  |
| 64       | -       | $0.08$  |        | $0.06$  |
| 128      | -       | $0.07$  |        | $0.05$  |
#### Distance Oracle
- Time

| k   | Boston         | Porto          | Jinan |
| --- | -------------- | -------------- | ----- |
| 2   | $0.49\pm0.04$  | $39.84\pm0.55$ |       |
| 4   | $0.31\pm0.01$* | $10.74\pm0.25$ |       |
| 8   | $0.35\pm0.01$  | $8.99\pm0.19$* |       |
| 16  | $0.53\pm0.02$  | $12.20\pm0.16$ |       |

- MRE

| k   | Boston         | Porto          | Jinan |
| --- | -------------- | -------------- | ----- |
| 2   | $0.59\pm0.04$  | $0.33\pm0.02$  |       |
| 4   | $0.69\pm0.08$* | $0.44\pm0.04$  |       |
| 8   | $0.74\pm0.06$  | $0.45\pm0.05$* |       |
| 16  | $0.75\pm0.10$  | $0.42\pm0.04$  |       |

#### ACH
- Time

| Boston        | Porto | Jinan |
| ------------- | ----- | ----- |
| $3.42\pm0.01$ | $\pm$ |       |


- MRE

| Boston | Porto | Jinan |
| ------ | ----- | ----- |
| $0.38$ |       |       |



---
## 7.31
- [ ] 写论文

### 论文片段
我们将我们的方法与其它6种最短路径查询算法和最短路径距离查询算法进行了比较，它们分别为：
1. Dijkstra；
3. Bellman-Ford；
2. A*；
4. ACH；
5. Distance Oracle；
6. ALT。

ACH、Distance Oracle与ALT则为三种只能求得最短路径长度的approximate algorithms。这三种近似算法的思路异曲同工，都是通过对原始graph进行预处理，来缩减query最短路径距离的时间。分别来说，ACH使用了Contraction Hierarchy的方法，通过收缩掉图中一些无关紧要的节点，并赋予节点不同的重要性，来简化最短路径的搜索；Distance Oracle在预处理时实现了一种能够快速查询的最短距离的数据结构，通过牺牲空间复杂度来换取时间复杂度；ALT则是一个改进后的A Star算法，此算法通过合理选择landmark并使用三角不等式来提供一个更加准确的启发式函数。值得一提的是，ALT算法作为改进后的A\*算法，其在landmark的选择上同样使用了真实地图中的经纬度信息。若仅仅依靠图的拓扑结构来确定landmark，那么随着地图规模的扩大，选择landmark所花费的时间将变得不可承受。

### BJ-Taxi数据集
轨迹的节点是一整条路，没什么用。

---
## 7.30
- [x] 运行CH代码
- [ ] 将CH代码修改为ACH
### ACH
[新找的网站](https://gpluo.cn/article/python-contracton-hierarchies/)上有CH代码及其测试代码。

网上的CH算法很多，但没有单纯的CH，都是优化过的CH。比较好运行的一个Python代码也是不精确的CH，好在找到了其参考文献。

上述网站的代码有缺陷，会出现大量距离为无穷的预测。

---
## 7.29
- [x] 注册OverReview
### ACH
#### 改进后的节点收缩
为了不直接在原图上加入新路径，引入第二边权。先令每条边的第二边权初始化为其本身的边权。对于$u$的邻居节点$v,w$，
- 如果两者之间不经过$u$的最短路径$P$长于$(1+\varepsilon)$倍的$(v,u)$和$(u,w)$第二边权的加和，即
	$$c(P)>(1+\varepsilon)(\tilde{c}(v,u)+\tilde{c}(u,w))$$
	则将边$(v,w)$加入到原图中，设其权重为$c(v,u)+c(u,w)$，其第二权重为$\tilde{c}(v,u)+\tilde{c}(u,w)$。
- 若$P$本来就比较短，不符合上面的情况，就按照下式求出$\gamma$
	$$c(P)=(1+\gamma)(\tilde{c}(v,u)+\tilde{c}(u,w))$$
	并将$P$上的每条边的第二权重按照以下式子更新：
	$$\tilde{c}(x,y)=\min\left\{ \tilde{c}(x,y),\frac{c(x,y)}{1+\gamma} \right\}$$

CH的节点收缩在网上有现成代码，但比较长，需要让ChatGPT分段转换。

有一个问题，如何求出$P$，网上的一种方法是用局部的Dijkstra来减小计算量，但目前没有代码。

#### 最短路径查询算法
最短路径查询使用一个双向的Dijkstra算法。此算法分为前向和后向，需要存储两套数据。双向Dijkstra算法在GitHub上同样有现成的Java代码，用ChatGPT转换为Python代码。

---
## 7.18
### G-Tree算法
1. 将图$G$作为根节点，分成$f$个大小相等的子图作为子节点，再将子图作为根节点，递归计算子图，直到所有子图的节点数小于等于$t$；
2. 树中的非叶子节点会记录此节点所对应子图的边界点两两之间的一个距离矩阵；树中的叶子节点会记录对应子图中所有点和边界点的距离矩阵。 

---
## 7.17
### 论文笔记：Continuous Trajectory Generation Based on Two-Stage GAN
1. 将原地图分割成不同的区域，将每个节点向它们所属的区域做一个映射，然后将每个区域缩成一个节点，先在这张区域图上寻找一条路径；
2. 在连接相邻两个区域的所有边中，随机选择一条边，当作所求路径真正要走的边（选择边的时候，会参考OD），这样能获得一组路径片段；
3. 最后在每个区域的内部求局部最短路径，连接刚刚得到的路径片段，得到整条最短路径。

其分割区域时使用了KaFFPa算法。方便的图分割算法可以通过metis库调用`metis.part_graph`实现。

---
## 7.15
### ACH
记边$(u,v)$的权重为$c(u,v)$。

> [!definition] 节点收缩 (Node Contraction)
> 对于有向图$G$中节点$u$的邻居节点$v,w$，我们记不经过$u$的$v,w$之间的最短路径为$P$。如果$v,w$之间的最短路径经过$u$，则添加一条权重为此最短路径长度的边$(v,w)$；如果$v,w$的最短路径就是$P$，则$P$称为**见证者(Witness)**。对$u$的所有邻居节点$v,w$进行这个操作后，就可以去掉$u$而不影响其它节点之间最短路径的长度。

在节点收缩时，我们不希望直接在$v,w$之间加上一条捷径。因此我们希望通过使用一条路径$P$去替代这条捷径，即便$P$可能比$v,w$间的最短路径稍长。

---
## 7.11
### ALT
为最大化$k$个地标之间的最小距离，我们使用最远地标选择找到地标。
> [!definition] 最远地标选择 (Farthest Landmark Selection)
> 1. 选择一个起始节点；
> 2. 找到距离此节点最远的节点，将其加入此节点集中；
> 3. 每次迭代都去找到距离此节点集最远的节点。

对于平面图，我们使用平面地标选择。
> [!definition] 平面地标选择 (Planar Landmark Selection)
> 先找到一个最靠近平面图中心的节点$c$，以此为中心将整个平面图划分成$k$个扇形区域，每个扇区选择一个离中心最远的节点。若生成的地标B十分靠近地标A所在扇区的边界，为避免两个地标过于靠近，我们将删除地标A。
