## 7.31
- [ ] 写论文

### 论文片段
我们将我们的方法与其它6种最短路径查询算法和最短路径距离查询算法进行了比较，它们分别为：
1. Dijkstra；
3. Bellman-Ford；
2. A*；
4. ACH；
5. Distance Oracle；
6. ALT。

其中Dijkstra、Bellman-Ford与A Star三种算法为最短路径算法，而ACH、Distance Oracle与ALT则为三种只能求得最短路径长度的approximate algorithms。这三种近似算法的思路异曲同工，都是通过对原始graph进行预处理，来缩减query最短路径距离的时间。分别来说，ACH使用了Contraction Hierarchy的方法，通过收缩掉图中一些无关紧要的节点，并赋予节点不同的重要性，来简化最短路径的搜索；Distance Oracle

### BJ-Taxi数据集
轨迹的节点是一整条路，没什么用。

---
## 7.30
- [x] 运行CH代码
- [ ] 将CH代码修改为ACH
### ACH
[新找的网站](https://gpluo.cn/article/python-contracton-hierarchies/)上有CH代码及其测试代码。

网上的CH算法很多，但没有单纯的CH，都是优化过的CH。比较好运行的一个Python代码也是不精确的CH，好在找到了其参考文献。

上述网站的代码有缺陷，会出现大量距离为无穷的预测。

---
## 7.29
- [x] 注册OverReview
### ACH
#### 改进后的节点收缩
为了不直接在原图上加入新路径，引入第二边权。先令每条边的第二边权初始化为其本身的边权。对于$u$的邻居节点$v,w$，
- 如果两者之间不经过$u$的最短路径$P$长于$(1+\varepsilon)$倍的$(v,u)$和$(u,w)$第二边权的加和，即
	$$c(P)>(1+\varepsilon)(\tilde{c}(v,u)+\tilde{c}(u,w))$$
	则将边$(v,w)$加入到原图中，设其权重为$c(v,u)+c(u,w)$，其第二权重为$\tilde{c}(v,u)+\tilde{c}(u,w)$。
- 若$P$本来就比较短，不符合上面的情况，就按照下式求出$\gamma$
	$$c(P)=(1+\gamma)(\tilde{c}(v,u)+\tilde{c}(u,w))$$
	并将$P$上的每条边的第二权重按照以下式子更新：
	$$\tilde{c}(x,y)=\min\left\{ \tilde{c}(x,y),\frac{c(x,y)}{1+\gamma} \right\}$$

CH的节点收缩在网上有现成代码，但比较长，需要让ChatGPT分段转换。

有一个问题，如何求出$P$，网上的一种方法是用局部的Dijkstra来减小计算量，但目前没有代码。

#### 最短路径查询算法
最短路径查询使用一个双向的Dijkstra算法。此算法分为前向和后向，需要存储两套数据。双向Dijkstra算法在GitHub上同样有现成的Java代码，用ChatGPT转换为Python代码。

---
## 7.18
### G-Tree算法
1. 将图$G$作为根节点，分成$f$个大小相等的子图作为子节点，再将子图作为根节点，递归计算子图，直到所有子图的节点数小于等于$t$；
2. 树中的非叶子节点会记录此节点所对应子图的边界点两两之间的一个距离矩阵；树中的叶子节点会记录对应子图中所有点和边界点的距离矩阵。 

---
## 7.17
### 论文笔记：Continuous Trajectory Generation Based on Two-Stage GAN
1. 将原地图分割成不同的区域，将每个节点向它们所属的区域做一个映射，然后将每个区域缩成一个节点，先在这张区域图上寻找一条路径；
2. 在连接相邻两个区域的所有边中，随机选择一条边，当作所求路径真正要走的边（选择边的时候，会参考OD），这样能获得一组路径片段；
3. 最后在每个区域的内部求局部最短路径，连接刚刚得到的路径片段，得到整条最短路径。

其分割区域时使用了KaFFPa算法。方便的图分割算法可以通过metis库调用`metis.part_graph`实现。

---
## 7.15
### ACH
记边$(u,v)$的权重为$c(u,v)$。

> [!definition] 节点收缩 (Node Contraction)
> 对于有向图$G$中节点$u$的邻居节点$v,w$，我们记不经过$u$的$v,w$之间的最短路径为$P$。如果$v,w$之间的最短路径经过$u$，则添加一条权重为此最短路径长度的边$(v,w)$；如果$v,w$的最短路径就是$P$，则$P$称为**见证者(Witness)**。对$u$的所有邻居节点$v,w$进行这个操作后，就可以去掉$u$而不影响其它节点之间最短路径的长度。

在节点收缩时，我们不希望直接在$v,w$之间加上一条捷径。因此我们希望通过使用一条路径$P$去替代这条捷径，即便$P$可能比$v,w$间的最短路径稍长。

---
## 7.11
### ALT
为最大化$k$个地标之间的最小距离，我们使用最远地标选择找到地标。
> [!definition] 最远地标选择 (Farthest Landmark Selection)
> 1. 选择一个起始节点；
> 2. 找到距离此节点最远的节点，将其加入此节点集中；
> 3. 每次迭代都去找到距离此节点集最远的节点。

对于平面图，我们使用平面地标选择。
> [!definition] 平面地标选择 (Planar Landmark Selection)
> 先找到一个最靠近平面图中心的节点$c$，以此为中心将整个平面图划分成$k$个扇形区域，每个扇区选择一个离中心最远的节点。若生成的地标B十分靠近地标A所在扇区的边界，为避免两个地标过于靠近，我们将删除地标A。
