## 7.18
- [ ] G-Tree实现

#### G-Tree算法
1. 将图$G$作为根节点，分成$f$个大小相等的子图作为子节点，再将子图作为根节点，递归计算子图，直到所有子图的节点数小于等于$t$；
2. 树中的非叶子节点会记录此节点所对应子图的边界点两两之间的一个距离矩阵；树中的叶子节点会记录对应子图中所有点和边界点的距离矩阵。 

- [ ] TD-G-Tree实现
## 7.17
#### 论文笔记：Continuous Trajectory Generation Based on Two-Stage GAN
1. 将原地图分割成不同的区域，将每个节点向它们所属的区域做一个映射，然后将每个区域缩成一个节点，先在这张区域图上寻找一条路径；
2. 在连接相邻两个区域的所有边中，随机选择一条边，当作所求路径真正要走的边（选择边的时候，会参考OD），这样能获得一组路径片段；
3. 最后在每个区域的内部求局部最短路径，连接刚刚得到的路径片段，得到整条最短路径。

其分割区域时使用了KaFFPa算法。方便的图分割算法可以通过metis库调用`metis.part_graph`实现。
