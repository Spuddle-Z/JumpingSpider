---
tags:
  - Knowledge
---
## 事务
> [!definition] 事务 (Transaction)
> 是用户定义的一系列数据库操作。为保持数据库系统的一致性，这些操作要么全做，要么全不做，是一个不可分割的工作单位。

*事务是数据库恢复和并发控制的基本单位。*

事务的结束有两个可能的状态：
- **COMMIT**：事务正常运行完成，提交事务中操作对数据库的所有更新，将其写回到磁盘上的物理数据库中；
- **ROLLBACK**：事务运行过程中异常终止，此时系统会将此事务中的所有已完成操作全部撤销，将事务回滚到事务开始前的状态。

事务的ACID特性：
- **原子性(Atomicity)**：事务是一个不可分割的操作序列；
- **一致性(Consistency)**：事务执行的效果必须要使数据库从一个一致性状态变为另一个一致性状态；
- **隔离性(Isolation)**：当事务并发执行时，一个事务的执行不能被其它事务所干扰；
- **持续性(Durability)**：也称为**永久性(Permanence)**，事务一旦提交，其对数据库中数据的改变应该是永久性的。
## 恢复的实现技术
### 基本概念
恢复操作的基本思想，是利用存储在其他地方的冗余数据，来重建不正确的数据。建立冗余数据分为两个方式：
- 数据转储(Dump)：备份整个数据；
- 登记日志文件(Logging)：记录数据的每次变化。

事务故障和系统故障只需要日志文件即可恢复，但介质故障和一些计算机病毒则同时需要数据转储与日志文件才能恢复。
### 数据转储
> [!definition] 转储
> ![[Pasted image 20240516101322.png|400]]
> DBA定期将整个数据库复制到磁带、磁盘等一些存储介质上备份起来的过程，这些备用数据称为**后备副本**。后备副本只能将数据库恢复到转储时的状态。

- **静态转储**：在系统中没有运行事务时进行转储，转储期间不允许对数据库进行任何操作。
	- 优点：实现简单；
	- 缺点：降低了数据库的可用性。
	- 恢复方法：重装静态转储的后备副本，然后利用日志文件恢复转储后的事务。
		![[Pasted image 20240516105303.png|500]]
- **动态转储**：转储可以与事务并发进行。
	- 优点：无须等待正在运行的事务结束，也不会影响新事务的运行；
	- 缺点：可能会破坏数据库的一致性，不能保证副本中的数据正确有效。
	- 恢复方法：需要把动态转储期间的事务运行登记到日志文件中，恢复时用后备副本加上日志文件才能恢复。
		![[Pasted image 20240516102704.png|475]]
- **海量转储**：每次转储整个数据库，恢复时更加方便，但转储整个数据库开销很大。
- **增量转储**：只转储在上次转储的基础上新更新过的数据，恢复起来会更麻烦，但转储时开销较小。
### 登记日志文件
> [!definition] 日志文件
> 用来记录事务对数据库的更新操作的文件。其内容由以下部分组成：
> - 各事务的*开始标记(BEGIN TRANSACTION)*；
> - 各事务的*结束标记(COMMIT或ROLLBACK)*；
> - 各事务中的每个*更新操作*。
> 
> 开始标记、结束标记和每个更新操作，均为日志文件中的一个**日志记录(Log Record)**

日志文件的用途：在事务故障、系统故障、介质故障后的数据恢复均需要使用到日志文件。

登记日志文件的原则：
- 登记次序严格按并行事务执行的时间顺序；
- 必须先写日志文件，后写数据库。因为在这两个操作之间如果发生故障，先修改数据库的话没法恢复，和没执行一样；但是先写日志文件的话，恢复时直接就能够恢复。
## 故障类别与其恢复策略

| 故障类别              | 定义                                            | 常见原因                                                 | 恢复方法                                                    |
| ----------------- | --------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------- |
| **事务故障**          | 由于事务内部的各种原因，导致事务未能运行完成。                       | 1. 运算溢出<br>2. 被应用程序终止<br>3. 并行事务出现死锁                 | 通过事务撤销(UNDO)恢复，即撤销当前事务对数据库的所有修改，将数据库恢复至执行此事务之前的状态。      |
| **系统故障**          | 系统故障是造成系统停止运转的事件，其会影响正在运行的所有事务，并导致内存中的信息全部丢失。 | 1. 操作系统或DBMS代码错误<br>2. 操作人员操作失误<br>3. CPU故障<br>4. 停电 | 1. UNDO所有未完成的事务；<br>2. 对于已经提交但还没写入磁盘的事务，需要重做(REDO)。<br> |
| **介质故障**或**硬件故障** | 外存中的数据部分或全部丢失，并影响所有相关事务。                      | 1. 磁盘损坏<br>2. 磁头碰撞<br>3. 瞬时强磁场干扰                     | 通过备份数据+日志文件恢复。                                          |
| **计算机病毒**         | 有些计算机病毒也会破坏硬盘中的数据。                            |                                                      | 通过备份数据+日志文件恢复。                                          |
### 事务故障及其恢复
> [!definition] 事务故障
> 由于事务内部的各种原因，导致事务未能运行完成。造成事务故障的常见原因有：
> 1. 运算溢出
> 2. 被应用程序终止
> 3. 并行事务出现死锁
> 4. ……

恢复事务故障的过程由系统自动完成，不需要用户干预。其需要利用日志文件撤销(UNDO)此事务已经对数据库进行的修改，具体步骤如下：
1. *反向*扫描日志文件；
2. 对扫描到的更新操作执行其逆操作（如原操作为插入操作，那么其逆操作就变为了删除操作）；
3. 继续逆向扫描下去，做同样处理，直到读到此事务的开始标记。
### 系统故障及其恢复
> [!definition] 系统故障
> 系统故障是造成系统停止运转的事件。其可能在两方面破坏数据库的一致性：
> - 一些未完成的事务的一部分更新已经写入数据库；
> - 一些已经提交的事务对数据库的更新还留在缓冲区，没来得及写入数据库。
> 
> 造成系统故障的原因有：
> 1. 操作系统或DBMS代码错误
> 2. 操作人员操作失误
> 3. CPU故障
> 4. 停电

系统故障的恢复会由系统在其重新启动时自动完成，同样不需要用户干预。其具体步骤如下：
1. *正向*扫描日志文件，建立两个队列
	- **重做队列(REDO-LIST)**：保存在故障发生前已经提交了的事务，这些事务同时有BEGIN TRANSACTION和COMMIT的记录；
	- **撤销队列(UNDO-LIST)**：保存在故障发生时尚未完成的事务，这些事务只有BEGIN TRANSACTION的记录。
1. 对UNDO-LIST里的事务进行UNDO处理，其实就是恢复事务故障的操作；
2. 对REDO-LIST中的每个事务日志记录中更新后的值写入数据库即可。

> [!example] 
> ![[Pasted image 20240516161113.png|175]]
> 上图例子中就应该REDO T1，UNDO T2
### 介质故障及其恢复
> [!definition] 介质故障
> 也叫**硬件故障**，外存中的数据部分或全部丢失，并影响所有相关事务。造成介质故障的原因：
> 1. 磁盘损坏
> 2. 磁头碰撞
> 3. 瞬时强磁场干扰

恢复系统故障需要DBA的介入，其遵循如下步骤：
1. 重装最新的后备数据库副本，使数据库恢复到最近一次转储时的一致性状态；
2. 对于静态转储的副本，重装后即为一致性状态；但对于动态转储的副本，则还需要装入转储时的日志文件副本，按照恢复系统故障的方法（REDO+UNDO）恢复后，才能将数据库恢复到一致性状态；
3. 依旧按照恢复系统故障的方法，装入转储结束后的日志文件副本。
## 具有检查点的恢复技术
每次恢复时，系统都会从头开始搜索整个日志文件，这样会耗费大量时间，并且重新REDO也十分耗时。为解决这两个问题，我们引入检查点。
> [!definition] 检查点 (Checkpoint)
> 检查点记录包含两部分——此时刻所有正在执行的事务清单，和这些事务对应的日志记录的地址。而每个检查点的地址则记录在重新开始文件中。如下图：
> ![[Pasted image 20240516231836.png|450]]
> 
> 在日志文件中每隔一定时间（如一小时），就增加一条检查点记录，同时将所有COMMIT的事务提交。这样在系统故障时，我们其实就不需要管最近检查点之前本来应该要REDO的事务了。
> ![[Pasted image 20240516231228.png|525]]

动态维护日志文件的方法：
1. 每次建立检查点时，先将当前*日志缓冲区*的所有日志记录写入*磁盘的日志文件*；
2. 在日志文件中写入一个*检查点记录*；
3. 再将当前*数据缓冲区*的所有数据记录写入*磁盘的数据库*中；
4. 把这个*检查点记录的地址*写入*重新开始文件*；
5. 周期性地执行上面四条操作。

利用检查点恢复的步骤：
1. 从重新开始文件中找到最近的检查点记录地址，由此找到对应的检查点记录；
2. 由该检查点记录得到当时所有运行事务的清单ACTIVE-LIST；
3. 建立UNDO-LIST与REDO-LIST，并将ACTIVE-LIST中的事务全部移到UNDO-LIST中；
4. 正向扫描检查点后的日志文件
	- 遇到新开始的事务，便将其移到UNDO-LIST中
	- 遇到COMMIT的事务，便将其从UNDO-LIST中移到REDO-LIST；
1. UNDO UNDO-LIST中的事务，REDO REDO-LIST中的事务。

> [!example] 
> ![[Pasted image 20240517161106.png|500]]

0513-2-2400