---
tags:
  - Knowledge
---
## 数据依赖
> [!definition] 函数依赖
> 也称函数决定，若对于$R(U)$的任意一个可能的关系$r$，$r$中不可能存在两个元组在$X$上的属性值相等，而在$Y$上的属性值不等，则称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X→Y$。
> 
> 在关系模式$R(U)$中，对于$U$的子集$X$和$Y$：
> - **非平凡的函数依赖**：如果$X→Y$，但$Y\nsubseteq X$，则称$X→Y$是非平凡的函数依赖。
> - **平凡的函数依赖**：如果$X→Y$，且$Y\subseteq X$，则称$X→Y$是平凡的函数依赖。由于*平凡函数依赖一定成立*，因此没什么意义，不作研究。
> - **完全函数依赖**：如果$X→Y$，并且对于$X$的任何一个真子集$X'$，都有$X'\nrightarrow Y$，则称$Y$完全函数依赖于$X$，记作$X\ce{->[F]}Y$。
> - **部分函数依赖**：如果$X→Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记作$X\ce{->[P]}Y$。
> - **传递函数依赖**：如果$X→Y(Y\nsubseteq X),Y\nrightarrow X,Y→Z(Z\nsubseteq Y)$，则称$Z$传递函数依赖于$X$，记为$X\ce{->[\text{传递}]}Z$；若$X\leftrightarrow Y$，则$X\ce{->[\text{直接}]}Z$。

设$K$为关系模式$R(U)$中的属性组，则可由以上概念重新定义[[关系模型和关系运算理论#关系的基本概念|码]]：
- **候选码(Candidate Key)**：若$K\ce{->[F]}U$，则$K$称为$R$的一个候选码。
- **超码**：若$K\ce{->[P]}U$，则$K$称为$R$的一个超码。*候选码是最小的超码。*
## 关系规范化
### 基本概念
- **范式**：符合某种级别的关系模式的集合，其分为第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、BC范式(BCNF)、第四范式(4NF)、第五范式(5NF)。若某一关系模式$R$为第$n$范式，记为$R\in nNF$。
- **规范化**：一个某级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。
- 规范化程度过低的关系可能会存在*插入异常*、*删除异常*、*修改复杂*、*数据冗余*等问题。
### 范式
- **第一范式**：若$R$的所有*属性均不可分*，则$R\in1NF$。
- 不满足第一范式的数据库模式*不能称为关系数据库*。
- 非规范化$\rightarrow$第一范式：
	![[Pasted image 20240305010623.png]]
	1. 展开属性![[Pasted image 20240305010700.png]]
	2. 展开元组![[Pasted image 20240305010828.png|300]]
	3. 模式分解![[Pasted image 20240305010941.png|375]]

> [!example] 不太好的关系模式
> 关系模式$SLC(Sno,Sdept,Sloc,Cno,Grade)$，五个属性分别为学号、系、住址、课程号、成绩，其函数依赖如下图：![[Pasted image 20240305214214.png|300]]
> 此种关系模式可能出现以下问题：
> 1. **插入异常**：由于课程号是主属性，因此学生未选课时，住址信息无法进入$SLC$；
> 2. **删除异常**：与插入异常相似，由于课程号是主属性，学生一旦放弃选修某课，将导致整个元组的删除；
> 3. **数据冗余**：一个学生修读了20门课程，其所属系与住址就重复存储了20遍；
> 4. **修改复杂**：学生若想转系，则可能要修改其选修的所有课的元组中的$Sdept$与$Sloc$。
> 
> 出现以上问题的*原因*：$Sdept$与$Sloc$只是部分函数依赖于$SLC$的码。

对于以上例子，可以通过*投影分解法*将其变为多个$2NF$的关系，来解决以上问题。
- **第二范式**：若关系$R\in1NF$，且每个非主属性都完全函数依赖于$R$的码，则$R\in2NF$。

> [!example] 依然不是好的关系
> 对于$2NF$的$SL(Sno,Sdept,Sloc)$，其中非主属性$Sloc$对码$Sno$是传递函数依赖，如图：![[Pasted image 20240305222626.png|200]]
> 此时会出现与$1NF$相似的问题。

对于以上例子，可以采用*关系分解法*将具有传递函数依赖的属性组逐层提取出来。
- **第三范式**：若关系模式$R$中不存在这样的码$X$、属性组$Y$与非主属性$Z(Z\nsubseteq Y)$，使得$X\to Y,Y\nrightarrow X,Y\to Z$成立，则$R\in3NF$。*注意此处没有$R\in2NF$的条件。*

> [!example] 一种易错的情况
> 在关系$STJ(S,T,J)$中，$S$为学生，$T$为老师，$J$为课程，此时有以下关系：
> - 每个老师教一门课，即$T\to J$；
> - 某一学生选定了某门课，就确定了一个老师，即$(S,J)\to T$；
> - 某个学生选修某个老师的课，就确定了课程，即$(S,T)\to J$。
>
>因此有两种候选码，如下图：![[Pasted image 20240309220536.png|300]]
>注意，此关系中没有非主属性，因此虽然关系中有部分函数依赖，但依然属于第三范式。
- **BC范式**：若关系模式$R\in1NF$，且对于$R$的每个函数依赖$X\to Y(Y\nsubseteq X)$，$X$必含有码，则$R\in BCNF$。
> [!note] BC范式与第三范式关系
> BC范式消除的是第三范式中可能出现的主属性部分或传递函数依赖于候选码的情况，因此若$R\in3NF$，且$R$只有一个候选码的话，则$R\in BCNF$。

综上，可以看到$BCNF\subseteq3NF\subseteq2NF\subseteq1NF$，逐层递进的规范化的基本思想就是通过将关系模式逐渐细分，来逐步消除不合适的数据依赖。
## 数据依赖的公理系统
### Armstrong公理系统
此公理系统是一套推理规则，用来从给定的一组函数依赖中求得其中蕴含的函数依赖。
- **逻辑蕴含**：对于关系模式$R(U,F)$，其中$F$表示一组函数依赖，若关系模式$R$下的任何一个关系$r$中，$X\to Y$都成立，则称$F$逻辑蕴含$X\to Y$。
- 对于关系模式$R(U,F)$来说，有以下的推理规则：
	- **自反律 (Reflexivity Rule)**：若$Y\subseteq X\subseteq U$，则$F$蕴含$X\to Y$（平凡函数依赖）。
	- **增广律 (Augmentation Rule)**：若$F$蕴含$X\to Y$，且$Z\subseteq U$，则$F$蕴含$XZ\to YZ$。
	- **传递律 (Transitivity Rule)**：若$F$蕴含$X\to Y$与$Y\to Z$，则同样蕴含$X\to Z$。
- 根据以上推理规则还可以得到下面三条推理规则：
	- **合并规则 (Union Rule)**：$X\to Y,X\to Z\implies X\to YZ$。
	- **伪传递规则 (Pseudo Transitivity Rule)**：$X\to Y,WY\to Z\implies XW\to Z$。
	- **分解规则 (Decomposition Rule)**：$X\to Y,Z\subseteq Y\implies X\to Z$。
### 闭包
- **函数依赖闭包**：关系模式$R(U,F)$中$F$逻辑蕴含的函数全体，称为$F$的闭包，记作$F^+$。
- **属性闭包**：若$F$为属性集$U$上的一组函数依赖，$X\subseteq U$，则称$X$能由$F$确定的所有属性的集合为$X$关于$F$的闭包，记作$X_{F}^{+}$。
- 关于闭包的引理：令$F$为$U$上的一组函数依赖，$X,Y\subseteq U$，则$X\to Y\iff Y\subseteq X_{F}^{+}$。
- 求闭包的算法：设输入为$X,F$，输出为$X_{F}^{+}$，则步骤如下
	1. 令$X^{(0)}=X$；
	2. 求$X^{(i)}$的所有子集能函数确定的属性集$B$；
	3. 令$X^{(i+1)}=B\cup X^{(i)}$；
	4. 若$X^{(i+1)}=X^{(i)}$或$X^{(i+1)}=U$，则$X^{(i)}$即为$X_{F}^{+}$；否则跳回步骤2。
- **函数依赖集等价**：若$G^{+}=F^{+}$，则称$F$覆盖$G$（同样$G$覆盖$F$），或者$F$与$G$等价，即两个函数依赖集等价$\iff$它们的闭包等价。
### 最小依赖集
- **最小依赖集**：若函数依赖集$F$满足下列条件，则称$F$为一个最小依赖集或最小覆盖：
	1. $F$中任一函数依赖的右部仅含有一个属性；
	2. $F$中不存在函数依赖$X\to A$，使得$F$等价于$F-\left\{X\to A\right\}$，即$F$中的所有函数依赖均不能用其它函数依赖导出；
	3. $F$中不存在函数依赖$X\to A$，$\exists Z\subsetneqq X$使得$F-\left\{X\to A\right\}\cup\left\{Z\to A\right\}$等价于$F$，即$F$中所有函数依赖左侧均不存在冗余属性。
### 关系模式分解的标准
- **函数依赖性**：关系分解后得到的每个关系，其最小依赖集应该是原关系的最小依赖集的子集，并且所有这些子集的并应该等于原关系的最小函数依赖集。
- **无损连接性**：将关系分解后得到的关系按照外码自然连接，应该能够得到原来的关系。