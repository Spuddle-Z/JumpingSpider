---
tags:
  - Knowledge
---
# 课程信息
1. 期末考试 60%
2. 编程大作业 20%
3. 最新进展报告大作业 10%
4. 作业 + 出勤 10%
# 概论
## 基本概念
- 数据：存储的基本对象
- 数据库：长期储存在计算机内、有组织、可共享的大量数据集合
- 数据库管理系统 (Database Management System, DBMS)：是位于用户与操作系统之间的一层**数据管理软件**
- 数据库系统 (Database System, DBS)：由**数据库**、**数据库管理系统**、**应用系统**和**数据库管理员**(Database Administrator, DBA)构成
	
	![[Pasted image 20240219145139.png|475]]
## 数据库系统特点
1. 数据的结构化
	- 数据的结构是用[[#数据模型]]描述的，无需程序去定义与解释
	- 如下图，数据是可以变长的，其最小存取单位是数据项
		![[Pasted image 20240220215049.png]]
1. 数据的独立性
	- 物理独立性：数据的物理存储改变时，应用程序不需要改变
	- 逻辑独立性：数据的逻辑结构改变时，应用程序也不需要改变
1. 数据的高共享性
	- 节省了存储空间，**降低**了数据的**冗余度**
	- **避免**了同一数据不同拷贝的**不一致性**与**不相容性**
	- 数据库系统弹性大，**易扩充**
1. 数据由DBMS统一管理
	- 安全性(Security)保护：防止泄密与破坏
	- 完整性(Integrity)检查：保持数据的正确性、有效性、相容性
## 数据模型
### 基本定义
建立数据模型即抽象、表示与处理现实世界中的数据和信息。

如下图，数据建模过程分为两步抽象。先把客观事物抽象成概念模型，再根据概念模型做出逻辑模型。
![[Pasted image 20240220220702.png]]
### 概念模型
- 定义：是现实世界到机器世界的一个中间层次，可以被用户读懂。
- 信息世界的基本概念：
	1. 实体：客观存在并可相互区别的事物
	2. 属性：实体具有的某一特性
	3. 码：唯一标识实体的属性集
	4. 域：属性的取值范围称为该属性的域
	5. 实体型：实体的类别
	6. 实体集：同型实体的集合
	7. 联系：实体内部或实体之间的联系
- E-R图：使用矩形表示实体，椭圆形表示属性，菱形表示联系，在无向边上标出联系的类型，如图![[Pasted image 20240219153301.png|215]]
> [!warning] 注*
> - 两个以上实体若想由一个联系连接，这些实体必须两两之间有关系
> - 对于码属性相同的实体，可以由一个实体集表示，然后添加一个属性来表示区分，如教师、教授、副教授之间可以用职称的属性进行区分
> - 除了码属性不能为空，其它属性都可以是空值，如学生的学号不能为空，但学生的专业一栏，在分专业之前就可以是空的
### 组成要素
1. **数据结构**：描述数据库组成对象与对象之间的联系，是系统的静态特性
2. **数据操作**：对数据库中对象的实例（值）允许执行的操作规则，是系统的动态特性
3. 数据的**完整性约束条件**：是一组完整性规则的集合，其中完整性规则指对数据及其联系的制约和储存规则，用来保证数据的正确、有效、相容（如对齐数据单位）
### 具体模型
#### 关系模型
1. 数据结构：表
2. 基本概念：
	- 关系(Relation)：一个关系通常对应一张表
	- 元组(Tuple)：表中一行即为一个元组
	- 属性(Attribute)：表中一列即为一个属性
	- 主码(Key)：表中的某一**属性组**（不一定是单一属性），可以唯一确定一个元组
	- 域(Domain)：属性的取值范围
	- 分量：某个属性的具体取值，每个分量必须是**不可分**的数据项，即不允许一个分量对应多个数据，查不出来
1. 优缺点：
	- 优点：
		1. 建立在严格的**数学概念**基础上
		2. 数据结构**简单清晰**
#### 层次模型
1. 定义：是一棵树
2. 特点：
3. 优点：
4. 缺点：
#### 网状模型
1. 定义：是一个有向图
2. 完整性约束：了解即可
3. 优缺点：
	- 优点：存取效率高
	- 缺点：结构比较复杂，不利于用户使用
## 数据库系统模式
### 三级模式 二级映象
![[Pasted image 20240222112906.png]]
- 三级模式
	- **内模式(Internal Schema)**：数据存储的模式，一个数据库只会有一个内模式。
	- **模式(Schema)**：选用什么样的逻辑模型，是整个系统的*核心*，与数据的存储无关，与应用的开发也无关，设计数据库时一般先确定模式。
	- **外模式(External Schema)**：确定用户使用哪一部分数据，通常是模式的子集，对于一个数据库可以有多个外模式。
- 二级映象
	- 外模式/模式映象：每个外模式都对应一个映象，保证数据的*逻辑独立性*。
	- 模式/内模式映象：保证了数据的*物理独立性*。
# 关系模型和关系运算理论
## 关系数据结构
### 关系的基本概念
1. **域(Domain)**：域是一组具有相同数据类型的值的集合。
2. **笛卡尔积(Cartesian Product)**：域上的一种集合运算。如：
	- ![[Pasted image 20240226142441.png]]
	- 其中一个小括号中的内容可以称为一个元组
1. **关系(Relation)**：$D_1× D_2×...× D_n$的*子集*叫作在域$D_1,D_2,...,D_n$上的关系， 表示为$R(D_1,D_2,...,D_n)$，其中$R$是*关系名*，$n$是关系的*目*或*度(Degree)*。关系分为三类：
	- **基本关系**（也称基本表或基表）：是实际存在的表，是实际数据的存储结构；
	- **查询表**：是经过查询操作后得到的结果集；
	- **视图**：视图并不存储实际的数据，只保存查询语句。
1. **元组(Tuple)**：关系中的每个元素是关系中的元组， 通常用$t$表示。
2. **属性(Attribute)**：关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性。*$n$目关系必有$n$个属性。*
3. **码(Key)**：其引入数据依赖后的数学定义[[#数据依赖|见此]]
	- **候选码(Candidate Key)**：若关系中的某一*属性组*（不一定只有一个属性）的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。此时候选码的各属性则称为*主属性(Prime Attribute)*，其它属性则称*非主属性(Non-key Attribute)*。
	- **全码(All-key)**：最极端的情况下，所有属性组是才是这个关系模式的候选码，此时称为全码。
	- **主码(Primary Key)**：若一个关系中有多个候选码，则选定其中一个为主码（因为候选码可以是一个属性组，因此主码也可以是一个*属性组*）。
### 基本关系性质
1. 列是同质的(Homogeneous)，即每一列中的分量来自同一个域。
2. 不同的列可来自同一域，由不同的属性名区分。
3. 列的顺序无所谓。
4. 任意两个元组的候选码不能完全相同。
5. 行的顺序无所谓。
6. 每一个分量必须是不可分的数据项，因此有一对行列即可查到唯一的分量，这是规范条件中*最基本*的一条。
### 关系模式
关系模式可形式化地表示为$R(U,D,dom,F)$
- $R$为关系名
- $U$为组成该关系的属性名集合
- $D$为属性组$U$中属性所来自的域
- $dom$为属性向域的映象集合
- $F$为属性间的数据依赖关系集合

通常来说我们用不到那么多的信息，关系模式可以简记为$R(U)$或$R(A_1,A_2,...,A_n)$，其中$R$为关系名，$A_i$为属性名。
### 关系数据库
在一个给定的应用领域中， 所有实体及实体之间联系的关系的集合构成一个关系数据库。
## 关系操作
1. 常用关系操作：
	- 查询：*选择*、*投影*、连接、除、交、*并*、*差*、*笛卡儿积*（斜体为五种**基本运算**，其它运算可以由基本运算得到）
	- 数据更新：插入、删除、修改
1. 关系操作就是集合操作，操作的对象和结果都是集合。
## 关系的完整性
### 实体完整性
**实体完整性规则(Entity Interity)**：*主属性*不能为空。
### 参照完整性
- **关系间的引用**：如现在有两个关系，学生（学号，姓名，*专业号*），专业（*专业号*，专业名）。学生关系的专业号属性的域被专业关系的专业号属性所限制，此时*学生的专业号引用专业的专业号*。
- **外码(Foreign Key**)：$F$是关系$R$的一个属性组，但不是$R$的主码，但$F$与关系$S$的主码$K$相对应，则称$F$为$R$的外码。此时$R$为*参照关系(Referencing Relation)*，$S$为*被参照关系(Referenced Relation)*或*目标关系(Target Relation)*。
	- $R$和$S$可能是同一个关系；
	- $K$和$F$域相同；
	- $K$和$F$不一定同名，但为了方便识别一般同名。
- **参照完整性规则**：还以上面为例，$R$中每个元组在$F$上的值，要不全为空值，要不等于$S$中某元组的主码值。
## 关系代数
### 基本概念
- 关系代数是一种抽象的查询语言，使用*对关系的运算*来表达查询，其有以下三个要素：
	- 运算对象：关系
	- 运算结果：关系
	- 运算符：集合运算符、关系运算符、算术比较符、逻辑运算符
- 相关记号：
	1. $t\in R$中$R$为关系，$t$为元组，$t[A_i]$表示元组$t$中对应属性$A_i$的分量；
	2. $A=\{A_1,A_2,...,A_n\}$，则$A$为属性组，$\bar{A}$为去掉$\{A_1,A_2,...,A_n\}$剩下的属性组；
	3. 设$t_1$为$m$列元组，$t_1$为$n$列元组，则$\overset{\LARGE{\frown}}{t_1 t_2}$表示两元组连接成的$m+n$列的元组，称为**元组的连接**；
	4. 设$X,Z$为$R$的属性组，当$t[X]=x$时，记$x$在$R$上的**象集(Image Set)**为$$Z_x=\{t[Z]|t\in R,t[X]=x\}$$，表示$R$的属性组$X$取值为$x$的元组，在属性组$Z$上的取值。
### 关系间的运算
#### 集合运算符
- **并(Union)**、**差(Difference)**、**交(Intersection)**三种运算都与集合运算相同，运算的对象为*目相同*的两个关系，不再赘述；
- **广义笛卡尔积(Extended Cartesian Product)**：即将一个关系中的所有元组，与另一个关系中的所有元组一一进行连接，设$m$目关系$R$有$k_1$个元组，$n$目关系$S$有$k_2$个元组，则$R\times S$为一个$m+n$目，$k_1\cdot k_2$元组的关系。
> [!warning] 注*
> 广义笛卡尔积也需要写连接条件。
#### 专门的关系运算
1. **选择(Selection)**：也称限制(Restriction)，即在关系$R$中选择满足给定条件的各元组，表示为$$\sigma_F(R)=\{t|t\in R\ \wedge\ F(t)\}$$，其中$F$为选择条件，是一个逻辑表达式。
2. **投影(Projection)**：在$R$中选择出某些属性列组成新的关系，表示为$$\pi_A(R)=\{t[A]|t\in R\}$$
> [!warning] 注*
> 投影操作后会自动清除重复的元组。
1. **连接(Join)**：也称为$\theta$连接，即从两个关系的笛卡尔积中选择属性组满足一定条件的元组，表示为$$R\Join_{A\theta B}S=\{\overset{\LARGE{\frown}}{t_R t_S}|t_R\in R\ \wedge\ t_S\in S\ \wedge\ t_R[A]\theta t_S[B]\}$$，其中$A,B$需要是$R$和$S$上可比的属性组，$\theta$为比较运算符。两种常用连接：
	- **等值连接(Equijoin)**：即$\theta$为$=$的连接运算；
	- **自然连接(Natural Join)**：即当$R$与$S$中有相同的属性组时，将$R\times S$中重复的属性组去掉，直接记作$R\Join S$。

> [!warning] 注*
> 由于选择与投影运算的时间复杂度为$O(n)$，而连接运算为$O(m\times n)$，因此一般按照选择-投影-连接的顺序运算。
1. **除(Division)**：设$R(X,Y),S(Y,Z)$，其中$X,Y,Z$均为属性组，$R\div S$即求$X$上哪些值所对应的象集，能包含$S$中$Y$上的所有的取值，结果即为$R$中的这些值。具体可见以下实例：
	![[Pasted image 20240302202925.png]]
	![[Pasted image 20240302202939.png]]
# 关系规范化基础
## 数据依赖
- **函数决定**与**函数依赖**：若对于$R(U)$的任意一个可能的关系$r$，$r$中不可能存在两个元组在$X$上的属性值相等，而在$Y$上的属性值不等，则称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X→Y$。
- 在关系模式$R(U)$中，对于$U$的子集$X$和$Y$：
	- **非平凡的函数依赖**：如果$X→Y$，但$Y\nsubseteq X$，则称$X→Y$是非平凡的函数依赖。
	- **平凡的函数依赖**：如果$X→Y$，且$Y\subseteq X$，则称$X→Y$是平凡的函数依赖。由于*平凡函数依赖一定成立*，因此没什么意义，不作研究。
	- **完全函数依赖**：如果$X→Y$，并且对于$X$的任何一个真子集$X'$，都有$X'\nrightarrow Y$，则称$Y$完全函数依赖于$X$，记作$X\ce{->[F]}Y$。
	- **部分函数依赖**：如果$X→Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记作$X\ce{->[P]}Y$。
	- **传递函数依赖**：如果$X→Y(Y\nsubseteq X),Y\nrightarrow X,Y→Z(Z\nsubseteq Y)$，则称$Z$传递函数依赖于$X$，记为$X\ce{->[\text{传递}]}Z$；若$X\leftrightarrow Y$，则$X\ce{->[\text{直接}]}Z$。
- 设$K$为关系模式$R(U)$中的属性组，则可由以上概念重新定义[[Database System Technology 数据库技术#关系的基本概念|码]]：
	- **候选码(Candidate Key)**：若$K\ce{->[F]}U$，则$K$称为$R$的一个候选码。
	- **超码**：若$K\ce{->[P]}U$，则$K$称为$R$的一个超码。*候选码是最小的超码。*
## 关系规范化
### 基本概念
- **范式**：符合某种级别的关系模式的集合，其分为第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、BC范式(BCNF)、第四范式(4NF)、第五范式(5NF)。若某一关系模式$R$为第$n$范式，记为$R\in nNF$。
- **规范化**：一个某级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。
- 规范化程度过低的关系可能会存在*插入异常*、*删除异常*、*修改复杂*、*数据冗余*等问题。
### 范式
- **第一范式**：若$R$的所有*属性均不可分*，则$R\in1NF$。
- 不满足第一范式的数据库模式*不能称为关系数据库*。
- 非规范化$\rightarrow$第一范式：
	![[Pasted image 20240305010623.png]]
	1. 展开属性![[Pasted image 20240305010700.png]]
	2. 展开元组![[Pasted image 20240305010828.png|300]]
	3. 模式分解![[Pasted image 20240305010941.png|375]]

> [!example] 不太好的关系模式
> 关系模式$SLC(Sno,Sdept,Sloc,Cno,Grade)$，五个属性分别为学号、系、住址、课程号、成绩，其函数依赖如下图：![[Pasted image 20240305214214.png|300]]
> 此种关系模式可能出现以下问题：
> 1. **插入异常**：由于课程号是主属性，因此学生未选课时，住址信息无法进入$SLC$；
> 2. **删除异常**：与插入异常相似，由于课程号是主属性，学生一旦放弃选修某课，将导致整个元组的删除；
> 3. **数据冗余**：一个学生修读了20门课程，其所属系与住址就重复存储了20遍；
> 4. **修改复杂**：学生若想转系，则可能要修改其选修的所有课的元组中的$Sdept$与$Sloc$。
> 
> 出现以上问题的*原因*：$Sdept$与$Sloc$只是部分函数依赖于$SLC$的码。

对于以上例子，可以通过*投影分解法*将其变为多个$2NF$的关系，来解决以上问题。
- **第二范式**：若关系$R\in1NF$，且每个非主属性都完全函数依赖于$R$的码，则$R\in2NF$。

> [!example] 依然不是好的关系
> 对于$2NF$的$SL(Sno,Sdept,Sloc)$，其中非主属性$Sloc$对码$Sno$是传递函数依赖，如图：![[Pasted image 20240305222626.png|200]]
> 此时会出现与$1NF$相似的问题。

对于以上例子，可以采用*关系分解法*将具有传递函数依赖的属性组逐层提取出来。
- **第三范式**：若关系模式$R$中不存在这样的码$X$、属性组$Y$与非主属性$Z(Z\nsubseteq Y)$，使得$X\to Y,Y\nrightarrow X,Y\to Z$成立，则$R\in3NF$。*注意此处没有$R\in2NF$的条件。*

> [!example] 一种易错的情况
> 在关系$STJ(S,T,J)$中，$S$为学生，$T$为老师，$J$为课程，此时有以下关系：
> - 每个老师教一门课，即$T\to J$；
> - 某一学生选定了某门课，就确定了一个老师，即$(S,J)\to T$；
> - 某个学生选修某个老师的课，就确定了课程，即$(S,T)\to J$。
>
>因此有两种候选码，如下图：![[Pasted image 20240309220536.png|300]]
>注意，此关系中没有非主属性，因此虽然关系中有部分函数依赖，但依然属于第三范式。
- **BC范式**：若关系模式$R\in1NF$，且对于$R$的每个函数依赖$X\to Y(Y\nsubseteq X)$，$X$必含有码，则$R\in BCNF$。
> [!note] BC范式与第三范式关系
> BC范式消除的是第三范式中可能出现的主属性部分或传递函数依赖于候选码的情况，因此若$R\in3NF$，且$R$只有一个候选码的话，则$R\in BCNF$。

综上，可以看到$BCNF\subseteq3NF\subseteq2NF\subseteq1NF$，逐层递进的规范化的基本思想就是通过将关系模式逐渐细分，来逐步消除不合适的数据依赖。
## 数据依赖的公理系统
### Armstrong公理系统
此公理系统是一套推理规则，用来从给定的一组函数依赖中求得其中蕴含的函数依赖。
- **逻辑蕴含**：对于关系模式$R(U,F)$，其中$F$表示一组函数依赖，若关系模式$R$下的任何一个关系$r$中，$X\to Y$都成立，则称$F$逻辑蕴含$X\to Y$。
- 对于关系模式$R(U,F)$来说，有以下的推理规则：
	- **自反律 (Reflexivity Rule)**：若$Y\subseteq X\subseteq U$，则$F$蕴含$X\to Y$（平凡函数依赖）。
	- **增广律 (Augmentation Rule)**：若$F$蕴含$X\to Y$，且$Z\subseteq U$，则$F$蕴含$XZ\to YZ$。
	- **传递律 (Transitivity Rule)**：若$F$蕴含$X\to Y$与$Y\to Z$，则同样蕴含$X\to Z$。
- 根据以上推理规则还可以得到下面三条推理规则：
	- **合并规则 (Union Rule)**：$X\to Y,X\to Z\implies X\to YZ$。
	- **伪传递规则 (Pseudo Transitivity Rule)**：$X\to Y,WY\to Z\implies XW\to Z$。
	- **分解规则 (Decomposition Rule)**：$X\to Y,Z\subseteq Y\implies X\to Z$。
### 闭包
- **函数依赖闭包**：关系模式$R(U,F)$中$F$逻辑蕴含的函数全体，称为$F$的闭包，记作$F^+$。
- **属性闭包**：若$F$为属性集$U$上的一组函数依赖，$X\subseteq U$，则称$X$能由$F$确定的所有属性的集合为$X$关于$F$的闭包，记作$X_{F}^{+}$。
- 关于闭包的引理：令$F$为$U$上的一组函数依赖，$X,Y\subseteq U$，则$X\to Y\iff Y\subseteq X_{F}^{+}$。
- 求闭包的算法：设输入为$X,F$，输出为$X_{F}^{+}$，则步骤如下
	1. 令$X^{(0)}=X$；
	2. 求$X^{(i)}$的所有子集能函数确定的属性集$B$；
	3. 令$X^{(i+1)}=B\cup X^{(i)}$；
	4. 若$X^{(i+1)}=X^{(i)}$或$X^{(i+1)}=U$，则$X^{(i)}$即为$X_{F}^{+}$；否则跳回步骤2。
- **函数依赖集等价**：若$G^{+}=F^{+}$，则称$F$覆盖$G$（同样$G$覆盖$F$），或者$F$与$G$等价，即两个函数依赖集等价$\iff$它们的闭包等价。
### 最小依赖集
- **最小依赖集**：若函数依赖集$F$东路下列条件，则称$F$为一个最小依赖集或最小覆盖：
	1. $F$中任一函数依赖的右部仅含有一个属性；
	2. $F$中不存在函数依赖$X\to A$，使得$F$等价于$F-\left\{X\to A\right\}$，即$F$中的所有函数依赖均不能用其它函数依赖导出；
	3. $F$中不存在函数依赖$X\to A$，$\exists Z\subsetneqq X$使得$F-\left\{X\to A\right\}\cup\left\{Z\to A\right\}$等价于$F$，即$F$中所有函数依赖左侧均不存在冗余属性。
### 关系模式分解的标准
- **函数依赖性**：关系分解后得到的每个关系，其最小依赖集应该是原关系的最小依赖集的子集，并且所有这些子集的并应该等于原关系的最小函数依赖集。
- **无损连接性**：将关系分解后得到的关系按照外码自然连接，应该能够得到原来的关系。
# 结构查询语言SQL
## 数据定义
### 基本表的定义、删除与修改
#### 定义基本表
