---
tags:
  - Knowledge
  - Code
aliases:
  - Algorithm
---
## 排序
### 堆排序
一个数组可以看作一个二叉树，下标0处为其根节点，则对于任意节点`i`：
- 其父节点为`i // 2`；
- 其左孩子为`2*i + 1`；
- 其右孩子为`2*i + 2`。

> [!definition] 堆排序 (Heap Sort)
> 大顶堆即一个子节点大于父节点的二叉树，小顶堆反之。若欲由小到大排序，则需要构造一个大顶堆。
> 1. 将一个无序数组按下标顺序依次检查其与父节点的大小关系，若大于其父节点，则与父节点交换位置，直到不再大于其父节点；
> 2. 当检查完所有节点，我们即得到了一个大顶堆；
> 3. 此时将树顶端的数与最后一个数交换，最大的数即已经排好了顺序，将其固定，并让顶端的数下沉，继续维持大顶堆；
> 4. 再将顶端的数与倒数第二个数交换，以此类推，直到所有数都被固定。

堆排序的时间复杂度是$O(n\log n)$，额外空间复杂度是$O(1)$，是不稳定排序。

### 快速排序
#### 原理
> [!definition] 快速排序 (Quick Sort)
> 随机选择一个pivot（通常是第一个数），把小于pivot的数都放到左边，大于pivot的数都放到右边，然后对左右两部分递归使用此方法。

^1ad534

其实现思路如下：
1. 令两个指针`l`和`r`分别指向队首和队尾；
2. 选`l`指向的数为pivot，记录下来；
3. 令`r`向左移动，遇到小于pivot的数停下，将其值赋给`l`；
4. 令`l`向右移动，遇到大于pivot的数停下，将其值赋给`r`；
5. 重复此过程，直到两指针相遇；
6. 对左右两部分递归调用此方法，直到起始时`l=r`。

### 代码
```cpp
void quickSort(int nums[], int start, int end) {
	if (start < end) {
		int l = start, r = end;
		int pivot = nums[l];
		while (l < r) {
			while (nums[r] >= pivot && l < r) { r--; }
			nums[l] = nums[r];
			while (nums[l] <= pivot && l < r) { l++; }
			nums[r] = nums[l];
		}
		nums[l] = pivot;
		quickSort(nums, start, l-1);
		quichSort(nums, r+1, end);
	}
	return;
}
```

> [!caution] 
> 移动左右指针的每一次循环，都需要保证`l < r`，这个条件在每个`while`循环中都要加上。

## 分治法
### 主定理
> [!definition] 分治法 (Divide and Conquer)
> 将一个问题逐层拆分成子问题，分别解决所有的子问题，再将子问题逐层合并成原问题的思想。

^aa6ac1

在分治法中常通过主定理来求得时间复杂度。

> [!theorem] 主定理 (Master Theorem)
> 若$T(n)=aT\left(\frac{n}{b}\right)+O\left(n^d\right)$，则有
> $$
> T(n)=
> \left\{\begin{aligned}
> & O\left(n^d\right) & ,a<b^d \\
> & O\left(n^{\log_ba}\right) & ,a>b^d \\
> & O\left(n^d\log n\right) & ,a=b^d
> \end{aligned}\right.
> $$

> [!proof] 
> 我们可以看到在原式中，$T(n)$为原问题，$T\left( \frac{n}{b} \right)$则为原问题拆分出的子问题，而$n^{d}$则为合并这些子问题所花费的时间。因此
> - 第0层合并需要$n^{d}$；
> - 第1层合并需要$\frac{a}{b^{d}}\cdot n^{d}$；
> - 第2层合并需要$\left( \frac{a}{b^{d}} \right)^3\cdot n^{d}$；
> - ……
> - 第$k$层合并需要$\left( \frac{a}{b^{d}} \right)^{k}\cdot n^{d}$。
> 
> 这里我们认为第$k$层中的每个子问题的规模为1，即
> $$\left( \frac{n}{b^{k}} \right)^{d}=1\implies k=\log_{b}n$$
> 将各层的耗时相加得到
> $$T(n)=n^{d}\sum_{i=0}^{k}\left(\frac{a}{b^{d}}\right)^{i}$$
> 令$q=\frac{a}{b^{d}}$，且通过等比数列求和常用的错位相减法可得
> $$(1-q)\cdot T(n)=n^{d}\cdot(1-q^{k+1})$$
> 对于上式，我们进行分类讨论：
> 1. 若$q<1$，则当$k$非常大时，$q^{k+1}$会趋近于0，因此有
> 	$$T(n)=n^{d}\frac{1-q^{k+1}}{1-q}\approx\frac{n^{d}}{1-q}=O(n^{d})$$
> 1. 若$q>1$，则当$k$非常大时，$\frac{q^{k+1}-1}{q-1}$中$q^{k}$项占主导，因此有
> 	$$T(n)=n^{d}\frac{q^{k+1}-1}{q-1}\approx n^{d}q^{k}$$
> 	将$k,q$代入上式，再由$x^{\log y}=y^{\log x}$可得
> 	$$T(n)\approx n^{d}q^{k}=O(n^{\log_{b}a})$$
> 1. 若$q=1$，直接代入
> 	$$T(n)=n^{d}\sum_{i=0}^{k}q^{i}=(k+1)n^{d}=O(n^{d}\log n)$$
> 
> QED.

### 相关算法
#### 快速选择
- **目的**：对于找到第k大的数这个问题(Top-k)，将数组全部排序必定会有一部分不必要的排序。
- **原理**：[[算法#^1ad534|快速排序]]的递归调用那一步，只需要调用左右两部分中包含第k大的数的那部分即可。
- **时间复杂度**：最快$O(n)$，最慢$O(n^2)$。
#### BFPTR算法
- **目的**：最优地解决top-k问题。
- **原理**：通过找中位数的中位数，来找到一个更好的pivot。
- **过程**：
	1. 将数组五个五个分组，找到每组的中位数；
	2. 再令这些中位数重复此操作，直到最后找到一个中位数的中位数，将此数作为pivot，再进行[[算法#快速选择|快速选择]]。

## 图算法
### DFS
#### 基本概念
> [!definition] 深度优先搜索 (Depth First Search, DFS)
> 遍历到一个节点时，如果其下游还有没有被遍历到的节点，则向此节点继续遍历下去；若其下游节点已经全部被遍历过，则回溯到其上游的节点。

DFS时间复杂度为$O(|E|+|V|)$。

#### 寻找强连通分量
可以用Tarjan算法区分开一个有向图中不同的[[图论#^fb6925|强连通分量]]。
> [!definition] Tarjan算法 (Tarjan's Algorithm)
> 我们定义：
> - $DFN(u)$为节点$u$被遍历的次序编号；
> - $LOW(u)$为从节点$u$能够返回到的节点的最小的次序编号。
> 那么算法如下：
> 1. 首次遍历$u$时，$LOW(u)=DFN(u)$，并将$u$入栈；
> 2. 访问$u$的相邻点$v$，有以下情况：
> 	1. $v$首次被遍历，对$v$进行DFS，回溯时有$LOW(u)=\min(LOW(u),LOW(v))$；
> 	2. 若$v$已经被遍历且在栈中，有$LOW(u)=\min(DFN(v),LOW(u))$；
> 	3. 若$v$已经被遍历且不在栈中，说明$v$所在强连通分量已经被处理了，这里不做操作。
> 3. 遍历完$u$的所有相邻点后，如果$LOW(u)=DFN(u)$，则$u$及其以上的所有节点都出栈。
> 
> > [!caution] 
> > 第二步的第二种情况下，由于更新$LOW(u)$用的是$\min(DFN(v),LOW(u))$，而不是$\min(LOW(v),LOW(u))$，所以最终的$LOW(u)$并不一定是节点$u$能够返回到的节点的最小的次序编号；但因为最后区分其属于哪个强连通分量是靠出栈的批次，而不是看$LOW$值，因此并不影响结果。

### BFS
#### 基本概念
> [!definition] 广度优先搜索 (Breadth First Search, BFS)
> 遍历到一个节点$u$时，先遍历与此节点相邻的节点$v$，然后再按同样的方式遍历$v$的所有相邻节点。

BFS时间复杂度：$O(|E|+|V|)$
#### 拓扑排序
> [!definition] 拓扑排序 (Topological Sorting)
> 对于一个[[图论#^a5cf02|DAG]]，将其所有的节点排成一个序列，若序列满足以下条件，此序列即为一个拓扑排序：
> - 每个节点出现且只出现一次；
> - 对于图中的任何一条边$u\to v$，$u$都排在$v$之前。

我们可以通过Kahn算法得到拓扑排序。

> [!definition] Kahn算法 (Kahn's Algorithm)
> 1. 计算DAG中的所有节点的入度，并将所有入度为零的节点入队；
> 2. 出队一个节点，遍历其所有的相邻节点，每遍历到一个节点就将此节点的入度减一，再将所有入度为零的节点入队；
> 3. 当队列为空时，节点的出队顺序即为拓扑排序的顺序。

#### 判断是否有环
对一个有向图执行Kahn算法，当队列为空时，若仍有节点未入队，此图中即有环；若所有节点都已入队，则此图为DAG。
#### 正权图最短路径
#Missing 
> [!definition] Dijkstra算法
> 即用BFS更新节点距离；时间复杂度为$O(|E|+|V|\log|V|)$；

^5c9f93

应用：正权图找最短路径。

4. Bellman-Ford算法松弛每条边来更新节点；时间复杂度为$O(|E|\cdot|V|)$；应用：负权图找最短路径、判断负环（循环$|V|$次看是否依然有节点更新，因为最短路径最长也就$|V|-1$条边）。

  

## 贪心算法
1. 基本思想：\\

选择一种局部最优的策略进行算法设计；用induction思想进行正确性分析。

参考思路：\\

归纳法：尝试证明每次决策都是某个最优解的子集，如证明Kruskal每次选完边仍然是某个最想生成树的子集。\\

反证法：假设某次决策不再是某个最优解的子集，通过交换等方法构造性地导出矛盾。

  

\textbf{Dynamic Programming}\par

1. DP算法基本设计思想：思考问题的基本递归解法；总结递归解法过程中所需的状态；将递归解法写成状态转移的方式；检查状态转移是否构成DAG；通过归纳法证明DP算法的正确性：关键说明转移这一步为什么成立（对应归纳证明那一步）。\\

参考案例：最长上升子序列、编辑距离、背包问题。\\

2. 优化DP（优先队列）：将又老又菜（没有竞争力）的保存状态踢出考虑范围。例如最长上升子序列优化：图中有2-2在，5-2就不可能被之后选中，因此可将优先队列2位置的5改为2。

![[DP.png]]

3. Floyd-Warshall算法：给$|V|$个点随机编号，$dist(k,i,j)$代表只允许经过前$k$个点的$v_i\to v_j$的最短路径长度，$dist(k,i,j)=\min\{dist(k-1,i,j),dist(k-1,i,k)+dist(k-1,k,j)\}$。因为$v_i\to v_j$的最短路径若不经过第$k$个点，$dist(k,i,j)$则可以由$dist(k-1,i,j)$得来；若经过第$k$个点，$v_k$即可把此最短路径分为$v_i\to v_k$与$v_k\to v_j$两条最短路径，此时$dist(k,i,j)=dist(k-1,i,k)+dist(k-1,k,j)$。所需三维列表边长均为$|V|$，所以时间复杂度为$O(|V|^3)$。\\

4. TSP问题：无向图中每条边都有其花费和报酬，从点$s$出发，经过所有的点再回到$s$，求最大利润。时间复杂度$O(|V|^2\cdot2^{|V|})$。

  

\textbf{Max-Flow}\par

1. Ford-Fulkerson算法：\\

基本思路：作residual network，边权等于每条边上剩余流量；找到$s\to t$的一条路径$p$，取其最窄处为最小流量，$p$上每条边减去此流量，反向边加上此流量，得到更新后的图；反复迭代到找不到$p$，程序停止。\\

该算法在无理数情况下无法保证终止；在有理数/整数情况下为$O(|E|\cdot f_{max})$，无法保证多项式时间复杂度。\\

2. Edmonds-Karp算法：\\

用BFS寻找$s\to t$的最短路径的方式来执行Ford-Fulkerson，保证了每次迭代时$s\to t$距离的单调性，从而实现多项式时间复杂度$O(|V|\cdot|E|^2)$（每次$O(|E|)$复杂度，迭代$|E|\cdot|V|$轮）。\\

3. Dinic算法：\\

用BFS建立level graph，在其中用DFS寻找阻塞流，最多找$O(|E|)$次，每次花费$O(|V|)$，因此此次迭代共需$O(|E|\cdot|V|)$。反复此操作，最多重复$|V|$次。整个算法共需$O(|V|^2\cdot|E|)$。\\

对于边权均为1的图，其每次迭代需要$O(|E|)$次，因为DFS只要经过某条边，其就可被消去。而后令其迭代$2|V|^\frac{2}{3}$或$|E|^\frac{1}{2}$次，可证明只需同样数量级的迭代即可完成。\\

4. Integrality Theorem: 如果所有的capacity是整数，那么一定存在整数最大流（整数流是指每条边上的流量为整数）。$\bigstar$是得分点，记得写上。\\

5. Max-Flow-Min-Cut Theorem：一个图的最大流等于最小割。\\

6. 最大流问题的应用：\\

Assignment相关问题、二分图的最大匹配 \\

![[MF3.png]]

![[MF1.png]]

![[MF2.png]]

  

\textbf{Linear Programming}\par

1. 单纯形法：沿可行域的边去找最优点，时间复杂度非多项式。\\

2. 对偶问题的转化：

![[LP1.png]]

3. 若上式中$A$是totally unimodular矩阵，且$b$为全整数向量，则x有整数最优解；同理，$A$为totally unimodular矩阵，$c$为全整数向量，则y有整数最优解。\\

4. 运用Strong Duality Theorem证明Max-Flow-Min-Cut Theorem。

![[LP2.png]]

  

\textbf{Basic Complexity Theory}\par

1. 证明NP：在多项式时间内可以验证。\\

2. 证明“一个问题是另一个问题的特殊情况”reduction来证明NP-hard。\\

3. 由1、2证明NP-complete。\\

4. 常见NP-complete问题：

![[NP1.png]]