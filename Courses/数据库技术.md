---
tags:
  - Knowledge
aliases:
  - Database System Technology
---
# 课程信息
1. 期末考试 60%
2. 编程大作业 20%
3. 最新进展报告大作业 10%
4. 作业 + 出勤 10%
# 概论
## 基本概念
![[Pasted image 20240219145139.png|375]]
- 数据：存储的基本对象；
- 数据库：长期储存在计算机内、有组织、可共享的大量数据集合；
- **数据库管理系统 (Database Management System, DBMS)**：是位于用户与操作系统之间的一层数据管理软件；
- **数据库管理员(Database Administrator, DBA)**：是从事管理和维护数据库管理系统的相关工作人员；
- **数据库系统 (Database System, DBS)**：由*数据库*、*数据库管理系统*、*应用系统*和*数据库管理员*构成。
## 数据库系统特点
1. 数据的结构化
	- 数据的结构是用[[#数据模型]]描述的，无需程序去定义与解释
	- 如下图，数据是可以变长的，其最小存取单位是数据项
		![[Pasted image 20240220215049.png]]
1. 数据的独立性
	- 物理独立性：数据的物理存储改变时，应用程序不需要改变
	- 逻辑独立性：数据的逻辑结构改变时，应用程序也不需要改变
1. 数据的高共享性
	- 节省了存储空间，**降低**了数据的**冗余度**
	- **避免**了同一数据不同拷贝的**不一致性**与**不相容性**
	- 数据库系统弹性大，**易扩充**
1. 数据由DBMS统一管理
	- 安全性(Security)保护：防止泄密与破坏
	- 完整性(Integrity)检查：保持数据的正确性、有效性、相容性
## 数据模型
### 基本定义
建立数据模型即抽象、表示与处理现实世界中的数据和信息。

如下图，数据建模过程分为两步抽象。先把客观事物抽象成概念模型，再根据概念模型做出逻辑模型。
![[Pasted image 20240220220702.png]]
### 概念模型
- 定义：是现实世界到机器世界的一个中间层次，可以被用户读懂。
- 信息世界的基本概念：
	1. 实体：客观存在并可相互区别的事物
	2. 属性：实体具有的某一特性
	3. 码：唯一标识实体的属性集
	4. 域：属性的取值范围称为该属性的域
	5. 实体型：实体的类别
	6. 实体集：同型实体的集合
	7. 联系：实体内部或实体之间的联系
- E-R图：使用矩形表示实体，椭圆形表示属性，菱形表示联系，在无向边上标出联系的类型，如图![[Pasted image 20240219153301.png|215]]
> [!caution] 注*
> - 两个以上实体若想由一个联系连接，这些实体必须两两之间有关系
> - 对于码属性相同的实体，可以由一个实体集表示，然后添加一个属性来表示区分，如教师、教授、副教授之间可以用职称的属性进行区分
> - 除了码属性不能为空，其它属性都可以是空值，如学生的学号不能为空，但学生的专业一栏，在分专业之前就可以是空的
### 组成要素
1. **数据结构**：描述数据库组成对象与对象之间的联系，是系统的静态特性
2. **数据操作**：对数据库中对象的实例（值）允许执行的操作规则，是系统的动态特性
3. 数据的**完整性约束条件**：是一组完整性规则的集合，其中完整性规则指对数据及其联系的制约和储存规则，用来保证数据的正确、有效、相容（如对齐数据单位）
### 具体模型
#### 关系模型
1. 数据结构：表
2. 基本概念：
	- 关系(Relation)：一个关系通常对应一张表
	- 元组(Tuple)：表中一行即为一个元组
	- 属性(Attribute)：表中一列即为一个属性
	- 主码(Key)：表中的某一**属性组**（不一定是单一属性），可以唯一确定一个元组
	- 域(Domain)：属性的取值范围
	- 分量：某个属性的具体取值，每个分量必须是**不可分**的数据项，即不允许一个分量对应多个数据，查不出来
1. 优缺点：
	- 优点：
		1. 建立在严格的**数学概念**基础上
		2. 数据结构**简单清晰**
#### 层次模型
1. 定义：是一棵树
2. 特点：
3. 优点：
4. 缺点：
#### 网状模型
1. 定义：是一个有向图
2. 完整性约束：了解即可
3. 优缺点：
	- 优点：存取效率高
	- 缺点：结构比较复杂，不利于用户使用
## 数据库系统模式
### 三级模式 二级映象
![[Pasted image 20240222112906.png]]
- 三级模式
	- **内模式(Internal Schema)**：数据存储的模式，一个数据库只会有一个内模式。
	- **模式(Schema)**：选用什么样的逻辑模型，是整个系统的*核心*，与数据的存储无关，与应用的开发也无关，设计数据库时一般先确定模式。
	- **外模式(External Schema)**：确定用户使用哪一部分数据，通常是模式的子集，对于一个数据库可以有多个外模式。
- 二级映象
	- 外模式/模式映象：每个外模式都对应一个映象，保证数据的*逻辑独立性*。
	- 模式/内模式映象：保证了数据的*物理独立性*。
# 关系模型和关系运算理论
## 关系数据结构
### 关系的基本概念
1. **域(Domain)**：域是一组具有相同数据类型的值的集合。
2. **笛卡尔积(Cartesian Product)**：域上的一种集合运算。如：
	- ![[Pasted image 20240226142441.png]]
	- 其中一个小括号中的内容可以称为一个元组
1. **关系(Relation)**：$D_1× D_2×...× D_n$的*子集*叫作在域$D_1,D_2,...,D_n$上的关系， 表示为$R(D_1,D_2,...,D_n)$，其中$R$是*关系名*，$n$是关系的*目*或*度(Degree)*。关系分为三类：
	- **基本关系**（也称基本表或基表）：是实际存在的表，是实际数据的存储结构；
	- **查询表**：是经过查询操作后得到的结果集；
	- **视图**：视图并不存储实际的数据，只保存查询语句。
1. **元组(Tuple)**：关系中的每个元素是关系中的元组， 通常用$t$表示。
2. **属性(Attribute)**：关系中不同列可以对应相同的域，为了加以区分，必须对每列起一个名字，称为属性。*$n$目关系必有$n$个属性。*
3. **码(Key)**：其引入数据依赖后的数学定义[[#数据依赖|见此]]
	- **候选码(Candidate Key)**：若关系中的某一*属性组*（不一定只有一个属性）的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。此时候选码的各属性则称为*主属性(Prime Attribute)*，其它属性则称*非主属性(Non-key Attribute)*。
	- **全码(All-key)**：最极端的情况下，所有属性组是才是这个关系模式的候选码，此时称为全码。
	- **主码(Primary Key)**：若一个关系中有多个候选码，则选定其中一个为主码（因为候选码可以是一个属性组，因此主码也可以是一个*属性组*）。
### 基本关系性质
1. 列是同质的(Homogeneous)，即每一列中的分量来自同一个域。
2. 不同的列可来自同一域，由不同的属性名区分。
3. 列的顺序无所谓。
4. 任意两个元组的候选码不能完全相同。
5. 行的顺序无所谓。
6. 每一个分量必须是不可分的数据项，因此有一对行列即可查到唯一的分量，这是规范条件中*最基本*的一条。
### 关系模式
关系模式可形式化地表示为$R(U,D,dom,F)$
- $R$为关系名
- $U$为组成该关系的属性名集合
- $D$为属性组$U$中属性所来自的域
- $dom$为属性向域的映象集合
- $F$为属性间的数据依赖关系集合

通常来说我们用不到那么多的信息，关系模式可以简记为$R(U)$或$R(A_1,A_2,...,A_n)$，其中$R$为关系名，$A_i$为属性名。
### 关系数据库
在一个给定的应用领域中， 所有实体及实体之间联系的关系的集合构成一个关系数据库。
## 关系操作
1. 常用关系操作：
	- 查询：*选择*、*投影*、连接、除、交、*并*、*差*、*笛卡儿积*（斜体为五种**基本运算**，其它运算可以由基本运算得到）
	- 数据更新：插入、删除、修改
1. 关系操作就是集合操作，操作的对象和结果都是集合。
## 关系的完整性
### 实体完整性
**实体完整性规则(Entity Interity)**：*主属性*不能为空。
### 参照完整性
- **关系间的引用**：如现在有两个关系，学生（学号，姓名，*专业号*），专业（*专业号*，专业名）。学生关系的专业号属性的域被专业关系的专业号属性所限制，此时*学生的专业号引用专业的专业号*。
- **外码(Foreign Key**)：$F$是关系$R$的一个属性组，但不是$R$的主码，但$F$与关系$S$的主码$K$相对应，则称$F$为$R$的外码。此时$R$为*参照关系(Referencing Relation)*，$S$为*被参照关系(Referenced Relation)*或*目标关系(Target Relation)*。
	- $R$和$S$可能是同一个关系；
	- $K$和$F$域相同；
	- $K$和$F$不一定同名，但为了方便识别一般同名。
- **参照完整性规则**：还以上面为例，$R$中每个元组在$F$上的值，要不全为空值，要不等于$S$中某元组的主码值。
## 关系代数
### 基本概念
- 关系代数是一种抽象的查询语言，使用*对关系的运算*来表达查询，其有以下三个要素：
	- 运算对象：关系
	- 运算结果：关系
	- 运算符：集合运算符、关系运算符、算术比较符、逻辑运算符
- 相关记号：
	1. $t\in R$中$R$为关系，$t$为元组，$t[A_i]$表示元组$t$中对应属性$A_i$的分量；
	2. $A=\{A_1,A_2,...,A_n\}$，则$A$为属性组，$\bar{A}$为去掉$\{A_1,A_2,...,A_n\}$剩下的属性组；
	3. 设$t_1$为$m$列元组，$t_1$为$n$列元组，则$\overset{\LARGE{\frown}}{t_1 t_2}$表示两元组连接成的$m+n$列的元组，称为**元组的连接**；
	4. 设$X,Z$为$R$的属性组，当$t[X]=x$时，记$x$在$R$上的**象集(Image Set)**为$$Z_x=\{t[Z]|t\in R,t[X]=x\}$$，表示$R$的属性组$X$取值为$x$的元组，在属性组$Z$上的取值。
### 关系间的运算
#### 集合运算符
- **并(Union)**、**差(Difference)**、**交(Intersection)**三种运算都与集合运算相同，运算的对象为*目相同*的两个关系，不再赘述；
- **广义笛卡尔积(Extended Cartesian Product)**：即将一个关系中的所有元组，与另一个关系中的所有元组一一进行连接，设$m$目关系$R$有$k_1$个元组，$n$目关系$S$有$k_2$个元组，则$R\times S$为一个$m+n$目，$k_1\cdot k_2$元组的关系。
> [!caution] 注*
> 广义笛卡尔积也需要写连接条件。
#### 专门的关系运算
1. **选择(Selection)**：也称限制(Restriction)，即在关系$R$中选择满足给定条件的各元组，表示为$$\sigma_F(R)=\{t|t\in R\ \wedge\ F(t)\}$$，其中$F$为选择条件，是一个逻辑表达式。
2. **投影(Projection)**：在$R$中选择出某些属性列组成新的关系，表示为$$\pi_A(R)=\{t[A]|t\in R\}$$
> [!caution] 注*
> 投影操作后会自动清除重复的元组。
1. **连接(Join)**：也称为$\theta$连接，即从两个关系的笛卡尔积中选择属性组满足一定条件的元组，表示为$$R\Join_{A\theta B}S=\{\overset{\LARGE{\frown}}{t_R t_S}|t_R\in R\ \wedge\ t_S\in S\ \wedge\ t_R[A]\theta t_S[B]\}$$，其中$A,B$需要是$R$和$S$上可比的属性组，$\theta$为比较运算符。两种常用连接：
	- **等值连接(Equijoin)**：即$\theta$为$=$的连接运算；
	- **自然连接(Natural Join)**：即当$R$与$S$中有相同的属性组时，将$R\times S$中重复的属性组去掉，直接记作$R\Join S$。
	
	由于选择与投影运算的时间复杂度为$O(n)$，而连接运算为$O(m\times n)$，因此一般按照*选择-投影-连接*的顺序运算。

> [!caution] 注\*
> 在这种连接两个表格的操作中，*只有自然连接不需要写连接条件*，等值连接、广义笛卡尔积都需要写连接条件。
1. **除(Division)**：设$R(X,Y),S(Y,Z)$，其中$X,Y,Z$均为属性组，$R\div S$即求$X$上哪些值所对应的象集，能包含$S$中$Y$上的所有的取值，结果即为$R$中的这些值。具体可见以下实例：
	![[Pasted image 20240302202925.png]]
	![[Pasted image 20240302202939.png]]
# 关系规范化基础
## 数据依赖
- **函数决定**与**函数依赖**：若对于$R(U)$的任意一个可能的关系$r$，$r$中不可能存在两个元组在$X$上的属性值相等，而在$Y$上的属性值不等，则称“$X$函数确定$Y$”或“$Y$函数依赖于$X$”，记作$X→Y$。
- 在关系模式$R(U)$中，对于$U$的子集$X$和$Y$：
	- **非平凡的函数依赖**：如果$X→Y$，但$Y\nsubseteq X$，则称$X→Y$是非平凡的函数依赖。
	- **平凡的函数依赖**：如果$X→Y$，且$Y\subseteq X$，则称$X→Y$是平凡的函数依赖。由于*平凡函数依赖一定成立*，因此没什么意义，不作研究。
	- **完全函数依赖**：如果$X→Y$，并且对于$X$的任何一个真子集$X'$，都有$X'\nrightarrow Y$，则称$Y$完全函数依赖于$X$，记作$X\ce{->[F]}Y$。
	- **部分函数依赖**：如果$X→Y$，但$Y$不完全函数依赖于$X$，则称$Y$部分函数依赖于$X$，记作$X\ce{->[P]}Y$。
	- **传递函数依赖**：如果$X→Y(Y\nsubseteq X),Y\nrightarrow X,Y→Z(Z\nsubseteq Y)$，则称$Z$传递函数依赖于$X$，记为$X\ce{->[\text{传递}]}Z$；若$X\leftrightarrow Y$，则$X\ce{->[\text{直接}]}Z$。
- 设$K$为关系模式$R(U)$中的属性组，则可由以上概念重新定义[[数据库技术#关系的基本概念|码]]：
	- **候选码(Candidate Key)**：若$K\ce{->[F]}U$，则$K$称为$R$的一个候选码。
	- **超码**：若$K\ce{->[P]}U$，则$K$称为$R$的一个超码。*候选码是最小的超码。*
## 关系规范化
### 基本概念
- **范式**：符合某种级别的关系模式的集合，其分为第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、BC范式(BCNF)、第四范式(4NF)、第五范式(5NF)。若某一关系模式$R$为第$n$范式，记为$R\in nNF$。
- **规范化**：一个某级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化。
- 规范化程度过低的关系可能会存在*插入异常*、*删除异常*、*修改复杂*、*数据冗余*等问题。
### 范式
- **第一范式**：若$R$的所有*属性均不可分*，则$R\in1NF$。
- 不满足第一范式的数据库模式*不能称为关系数据库*。
- 非规范化$\rightarrow$第一范式：
	![[Pasted image 20240305010623.png]]
	1. 展开属性![[Pasted image 20240305010700.png]]
	2. 展开元组![[Pasted image 20240305010828.png|300]]
	3. 模式分解![[Pasted image 20240305010941.png|375]]

> [!example] 不太好的关系模式
> 关系模式$SLC(Sno,Sdept,Sloc,Cno,Grade)$，五个属性分别为学号、系、住址、课程号、成绩，其函数依赖如下图：![[Pasted image 20240305214214.png|300]]
> 此种关系模式可能出现以下问题：
> 1. **插入异常**：由于课程号是主属性，因此学生未选课时，住址信息无法进入$SLC$；
> 2. **删除异常**：与插入异常相似，由于课程号是主属性，学生一旦放弃选修某课，将导致整个元组的删除；
> 3. **数据冗余**：一个学生修读了20门课程，其所属系与住址就重复存储了20遍；
> 4. **修改复杂**：学生若想转系，则可能要修改其选修的所有课的元组中的$Sdept$与$Sloc$。
> 
> 出现以上问题的*原因*：$Sdept$与$Sloc$只是部分函数依赖于$SLC$的码。

对于以上例子，可以通过*投影分解法*将其变为多个$2NF$的关系，来解决以上问题。
- **第二范式**：若关系$R\in1NF$，且每个非主属性都完全函数依赖于$R$的码，则$R\in2NF$。

> [!example] 依然不是好的关系
> 对于$2NF$的$SL(Sno,Sdept,Sloc)$，其中非主属性$Sloc$对码$Sno$是传递函数依赖，如图：![[Pasted image 20240305222626.png|200]]
> 此时会出现与$1NF$相似的问题。

对于以上例子，可以采用*关系分解法*将具有传递函数依赖的属性组逐层提取出来。
- **第三范式**：若关系模式$R$中不存在这样的码$X$、属性组$Y$与非主属性$Z(Z\nsubseteq Y)$，使得$X\to Y,Y\nrightarrow X,Y\to Z$成立，则$R\in3NF$。*注意此处没有$R\in2NF$的条件。*

> [!example] 一种易错的情况
> 在关系$STJ(S,T,J)$中，$S$为学生，$T$为老师，$J$为课程，此时有以下关系：
> - 每个老师教一门课，即$T\to J$；
> - 某一学生选定了某门课，就确定了一个老师，即$(S,J)\to T$；
> - 某个学生选修某个老师的课，就确定了课程，即$(S,T)\to J$。
>
>因此有两种候选码，如下图：![[Pasted image 20240309220536.png|300]]
>注意，此关系中没有非主属性，因此虽然关系中有部分函数依赖，但依然属于第三范式。
- **BC范式**：若关系模式$R\in1NF$，且对于$R$的每个函数依赖$X\to Y(Y\nsubseteq X)$，$X$必含有码，则$R\in BCNF$。
> [!note] BC范式与第三范式关系
> BC范式消除的是第三范式中可能出现的主属性部分或传递函数依赖于候选码的情况，因此若$R\in3NF$，且$R$只有一个候选码的话，则$R\in BCNF$。

综上，可以看到$BCNF\subseteq3NF\subseteq2NF\subseteq1NF$，逐层递进的规范化的基本思想就是通过将关系模式逐渐细分，来逐步消除不合适的数据依赖。
## 数据依赖的公理系统
### Armstrong公理系统
此公理系统是一套推理规则，用来从给定的一组函数依赖中求得其中蕴含的函数依赖。
- **逻辑蕴含**：对于关系模式$R(U,F)$，其中$F$表示一组函数依赖，若关系模式$R$下的任何一个关系$r$中，$X\to Y$都成立，则称$F$逻辑蕴含$X\to Y$。
- 对于关系模式$R(U,F)$来说，有以下的推理规则：
	- **自反律 (Reflexivity Rule)**：若$Y\subseteq X\subseteq U$，则$F$蕴含$X\to Y$（平凡函数依赖）。
	- **增广律 (Augmentation Rule)**：若$F$蕴含$X\to Y$，且$Z\subseteq U$，则$F$蕴含$XZ\to YZ$。
	- **传递律 (Transitivity Rule)**：若$F$蕴含$X\to Y$与$Y\to Z$，则同样蕴含$X\to Z$。
- 根据以上推理规则还可以得到下面三条推理规则：
	- **合并规则 (Union Rule)**：$X\to Y,X\to Z\implies X\to YZ$。
	- **伪传递规则 (Pseudo Transitivity Rule)**：$X\to Y,WY\to Z\implies XW\to Z$。
	- **分解规则 (Decomposition Rule)**：$X\to Y,Z\subseteq Y\implies X\to Z$。
### 闭包
- **函数依赖闭包**：关系模式$R(U,F)$中$F$逻辑蕴含的函数全体，称为$F$的闭包，记作$F^+$。
- **属性闭包**：若$F$为属性集$U$上的一组函数依赖，$X\subseteq U$，则称$X$能由$F$确定的所有属性的集合为$X$关于$F$的闭包，记作$X_{F}^{+}$。
- 关于闭包的引理：令$F$为$U$上的一组函数依赖，$X,Y\subseteq U$，则$X\to Y\iff Y\subseteq X_{F}^{+}$。
- 求闭包的算法：设输入为$X,F$，输出为$X_{F}^{+}$，则步骤如下
	1. 令$X^{(0)}=X$；
	2. 求$X^{(i)}$的所有子集能函数确定的属性集$B$；
	3. 令$X^{(i+1)}=B\cup X^{(i)}$；
	4. 若$X^{(i+1)}=X^{(i)}$或$X^{(i+1)}=U$，则$X^{(i)}$即为$X_{F}^{+}$；否则跳回步骤2。
- **函数依赖集等价**：若$G^{+}=F^{+}$，则称$F$覆盖$G$（同样$G$覆盖$F$），或者$F$与$G$等价，即两个函数依赖集等价$\iff$它们的闭包等价。
### 最小依赖集
- **最小依赖集**：若函数依赖集$F$东路下列条件，则称$F$为一个最小依赖集或最小覆盖：
	1. $F$中任一函数依赖的右部仅含有一个属性；
	2. $F$中不存在函数依赖$X\to A$，使得$F$等价于$F-\left\{X\to A\right\}$，即$F$中的所有函数依赖均不能用其它函数依赖导出；
	3. $F$中不存在函数依赖$X\to A$，$\exists Z\subsetneqq X$使得$F-\left\{X\to A\right\}\cup\left\{Z\to A\right\}$等价于$F$，即$F$中所有函数依赖左侧均不存在冗余属性。
### 关系模式分解的标准
- **函数依赖性**：关系分解后得到的每个关系，其最小依赖集应该是原关系的最小依赖集的子集，并且所有这些子集的并应该等于原关系的最小函数依赖集。
- **无损连接性**：将关系分解后得到的关系按照外码自然连接，应该能够得到原来的关系。
# 数据库设计
## 概述
一个数据库的设计一般要经历如下步骤：
![[Pasted image 20240328154352.png]]
## 需求分析
难点主要在用户缺少计算机知识，设计人员则缺少用户的专业知识，解决方法只能是不断地深入交流。

一般采用**结构化分析方法(Structured Analysis, SA)**来分析与表达用户需求：
- 从最上层的系统组织机构入手
- 自顶向下，逐层分解
- 最后用*数据流图*与*数据字典*描述系统
> [!example] 
> ![[Pasted image 20240328161149.png]]
> 根据以上需求，画出第一层的数据流图，虚线部分是系统的边界：
> ![[Pasted image 20240328161358.png]]
> 一般不希望系统太复杂，所以会细分成更小的数据流图，如下是接收订单的第二层数据流图：
> ![[Pasted image 20240328161609.png|450]]
> 处理订单的第二层数据流图：
> ![[Pasted image 20240328163046.png|500]]
> 开发票的第二层数据流图：
> ![[Pasted image 20240328163131.png|400]]
> 支付过账的第二层数据流图：
> ![[Pasted image 20240328163304.png|400]]
> 

- **数据字典**：是关于数据库中数据的描述，是元数据，而不是数据本身。其包括*数据项*、*数据结构*、*数据流*、*数据存储*、*处理过程*。
- **数据项**：是最小的、不可再分的数据单位。
	> [!example] 
	> 一个典型的数据项如下：
	> ![[Pasted image 20240328164102.png]]
- **数据结构**：反映了数据之间的组合关系，可以由若干个数据项与数据结构组成。
	> [!example] 
	> ![[Pasted image 20240328164824.png]]
- **数据流**：是数据结构在系统内传输的路径。
	> [!example] 
	> ![[Pasted image 20240328165155.png]]
- **数据存储**：是数据结构停留或保存的地方，也是数据流的来源或去向。
	> [!example] 
	> ![[Pasted image 20240328165334.png]]
- **处理过程**：处理过程的具体处理逻辑一般用判定表或判定树来描述，数据字典中只需要描述处理过程的说明性信息。
	> [!example] 
	> ![[Pasted image 20240328200303.png]]

## 概念结构设计
### 大致流程
**概念结构设计**：将需求分析得到的用户需求抽象为信息结构。*E-R模型*是描述概念模型的工具。概念结构设计的常用策略如下图所示：
![[Pasted image 20240328201131.png|500]]
1. 先在多层的数据流图中选择一个适当层次的数据流图；
2. 将此层次各局部应用涉及的数据从数据字典里抽取出来，据此设计E-R图；
	> [!note] 实体与属性的划分原则
	> 为简化E-R图，现实世界中的事物凡是能作为属性对待的，应尽量作为属性；但属性不能再具有需要被的性质。且属性也不能再和其他实体之间产生联系，若不满足这两条，则只能当作实体来处理。
1. 完成各个局部的E-R图之后，需要将这些E-R图集成成为一个更大的E-R图。

在合并E-R图的过程中，可能会出现三类冲突：
1. **属性冲突**
	- 属性域冲突：属性值的*类型*、*取值范围*与*取值集合*不同；
	- 属性取值单位冲突。
1. **命名冲突**
	- 同名异义：不同意义的对象在不同的E-R图中起了相同的名字；
	- 异名同义：同一意义的对象在不同的E-R图中起了不同的名字。
1. **结构冲突**
	- 同一对象在不同应用中具有不同的抽象；
	- 同一实体在不同分E-R图中所包含的属性个数和属性排列次序不完全相同；
	- 实体之间的联系在不同局部视图中呈现不同的类型。
### 修改与重构
- **冗余**：冗余的数据是指可由基本数据导出的数据，冗余的联系是指可由其他联系导出的联系。
> [!note] 
对于一些常用的冗余数据，也是需要保留的，消除后反而会降低效率。

消除冗余的方法：
- 通过数据项之间的逻辑关系来推导出冗余，进而消除冗余。
	> [!example] 
	> 图中通过*产品消耗零件量*与*零件使用材料量*就可以推出*产品消耗的材料量*，那么产品与材料之间的这个关系就属于冗余的关系。
	> ![[Pasted image 20240328204047.png|500]]
- 可以通过*规范化理论*来消除冗余：
	1. 确定实体之间的数据依赖$F_{L}$；
	2. 求$F_{L}$的最小覆盖$G_{L}$，再求二者差集$D=F_{L}-G_{L}$；
	3. 逐一考察$D$中的函数依赖，确定是否是冗余的联系。
		> [!note] 
		> 冗余的联系一定在$D$中，而$D$中的联系不一定是冗余的。
## 逻辑结构设计
每个*实体*、*多对多的联系*与*三个及以上实体间的多元联系*都要转换成一个关系模式，一对多的关系则可以选择向多的那一端合并，一对一的关系可向任意一端合并（合并即指成为另一端实体的属性）。
> [!caution] 
> 关系模式中要用*下划线标出主码*并*用下波浪线标出外码*。

数据模型的优化方法：
1. **依据规范化理论进行优化**：即确定每个关系模式所属范式，要根据实际情况确定规范化程度，有时甚至要降低规范化程度。
2. **对关系模式进行分解**：两种分解方法的原则都是*提高效率*
	- **水平分解**：按照元组分为若干子集合，以提高系统效率。一些应用满足*80/20原则*，即只有20%的数据会经常被使用，对于这些数据适合使用水平分解。
	- **垂直分解**：与水平分解相对应，按照属性分解为若干子集合。

还可以从用户的角度来*设计外模式*，即定义不同的视图，只展示部分数据，来在满足特定任务的需求前提下提高效率。
## 物理结构设计
> [!definition] 数据库的物理结构
> 指数据库在物理设备上的*存储结构*与*存取方法*，由数据库管理系统决定。

数据库的存取方法有索引方法（包括B+树索引与哈希索引）和聚簇方法。其主要思想为通过按照一定结构保存数据，来加速常用的搜索，但同时会牺牲不常用搜索的效率。
> [!definition] 聚簇 (Cluster)
> 为了提高某一属性的搜索效率，将这个*属性值相同*的元组保存在*连续*的物理空间上，这个属性被称作**聚簇码**。

确定数据存放位置的基本原则：将数据按照存取频率较高的*易变部分*与存取频率较低的*稳定部分*来分开存放。

# 数据库恢复
## 事务
> [!definition] 事务 (Transaction)
> 是用户定义的一系列数据库操作。为保持数据库系统的一致性，这些操作要么全做，要么全不做，是一个不可分割的工作单位。

*事务是数据库恢复和并发控制的基本单位。*

事务的结束有两个可能的状态：
- **COMMIT**：事务正常运行完成，提交事务中操作对数据库的所有更新，将其写回到磁盘上的物理数据库中；
- **ROLLBACK**：事务运行过程中异常终止，此时系统会将此事务中的所有已完成操作全部撤销，将事务回滚到事务开始前的状态。

事务的ACID特性：
- **原子性(Atomicity)**：事务是一个不可分割的操作序列；
- **一致性(Consistency)**：事务执行的效果必须要使数据库从一个一致性状态变为另一个一致性状态；
- **隔离性(Isolation)**：当事务并发执行时，一个事务的执行不能被其它事务所干扰；
- **持续性(Durability)**：也称为**永久性(Permanence)**，事务一旦提交，其对数据库中数据的改变应该是永久性的。
## 恢复的实现技术
### 基本概念
恢复操作的基本思想，是利用存储在其他地方的冗余数据，来重建不正确的数据。建立冗余数据分为两个方式：
- 数据转储(Dump)：备份整个数据；
- 登记日志文件(Logging)：记录数据的每次变化。

事务故障和系统故障只需要日志文件即可恢复，但介质故障和一些计算机病毒则同时需要数据转储与日志文件才能恢复。
### 数据转储
> [!definition] 转储
> ![[Pasted image 20240516101322.png|400]]
> DBA定期将整个数据库复制到磁带、磁盘等一些存储介质上备份起来的过程，这些备用数据称为**后备副本**。后备副本只能将数据库恢复到转储时的状态。

- **静态转储**：在系统中没有运行事务时进行转储，转储期间不允许对数据库进行任何操作。
	- 优点：实现简单；
	- 缺点：降低了数据库的可用性。
	- 恢复方法：重装静态转储的后备副本，然后利用日志文件恢复转储后的事务。
		![[Pasted image 20240516105303.png|500]]
- **动态转储**：转储可以与事务并发进行。
	- 优点：无须等待正在运行的事务结束，也不会影响新事务的运行；
	- 缺点：可能会破坏数据库的一致性，不能保证副本中的数据正确有效。
	- 恢复方法：需要把动态转储期间的事务运行登记到日志文件中，恢复时用后备副本加上日志文件才能恢复。
		![[Pasted image 20240516102704.png|475]]
- **海量转储**：每次转储整个数据库，恢复时更加方便，但转储整个数据库开销很大。
- **增量转储**：只转储在上次转储的基础上新更新过的数据，恢复起来会更麻烦，但转储时开销较小。
### 登记日志文件
> [!definition] 日志文件
> 用来记录事务对数据库的更新操作的文件。其内容由以下部分组成：
> - 各事务的*开始标记(BEGIN TRANSACTION)*；
> - 各事务的*结束标记(COMMIT或ROLLBACK)*；
> - 各事务中的每个*更新操作*。
> 
> 开始标记、结束标记和每个更新操作，均为日志文件中的一个**日志记录(Log Record)**

日志文件的用途：在事务故障、系统故障、介质故障后的数据恢复均需要使用到日志文件。

登记日志文件的原则：
- 登记次序严格按并行事务执行的时间顺序；
- 必须先写日志文件，后写数据库。因为在这两个操作之间如果发生故障，先修改数据库的话没法恢复，和没执行一样；但是先写日志文件的话，恢复时直接就能够恢复。
## 故障类别与其恢复策略

| 故障类别              | 定义                                            | 常见原因                                                 | 恢复方法                                                    |
| ----------------- | --------------------------------------------- | ---------------------------------------------------- | ------------------------------------------------------- |
| **事务故障**          | 由于事务内部的各种原因，导致事务未能运行完成。                       | 1. 运算溢出<br>2. 被应用程序终止<br>3. 并行事务出现死锁                 | 通过事务撤销(UNDO)恢复，即撤销当前事务对数据库的所有修改，将数据库恢复至执行此事务之前的状态。      |
| **系统故障**          | 系统故障是造成系统停止运转的事件，其会影响正在运行的所有事务，并导致内存中的信息全部丢失。 | 1. 操作系统或DBMS代码错误<br>2. 操作人员操作失误<br>3. CPU故障<br>4. 停电 | 1. UNDO所有未完成的事务；<br>2. 对于已经提交但还没写入磁盘的事务，需要重做(REDO)。<br> |
| **介质故障**或**硬件故障** | 外存中的数据部分或全部丢失，并影响所有相关事务。                      | 1. 磁盘损坏<br>2. 磁头碰撞<br>3. 瞬时强磁场干扰                     | 通过备份数据+日志文件恢复。                                          |
| **计算机病毒**         | 有些计算机病毒也会破坏硬盘中的数据。                            |                                                      | 通过备份数据+日志文件恢复。                                          |
### 事务故障及其恢复
> [!definition] 事务故障
> 由于事务内部的各种原因，导致事务未能运行完成。造成事务故障的常见原因有：
> 1. 运算溢出
> 2. 被应用程序终止
> 3. 并行事务出现死锁
> 4. ……

恢复事务故障的过程由系统自动完成，不需要用户干预。其需要利用日志文件撤销(UNDO)此事务已经对数据库进行的修改，具体步骤如下：
1. *反向*扫描日志文件；
2. 对扫描到的更新操作执行其逆操作（如原操作为插入操作，那么其逆操作就变为了删除操作）；
3. 继续逆向扫描下去，做同样处理，直到读到此事务的开始标记。
### 系统故障及其恢复
> [!definition] 系统故障
> 系统故障是造成系统停止运转的事件。其可能在两方面破坏数据库的一致性：
> - 一些未完成的事务的一部分更新已经写入数据库；
> - 一些已经提交的事务对数据库的更新还留在缓冲区，没来得及写入数据库。
> 
> 造成系统故障的原因有：
> 1. 操作系统或DBMS代码错误
> 2. 操作人员操作失误
> 3. CPU故障
> 4. 停电

系统故障的恢复会由系统在其重新启动时自动完成，同样不需要用户干预。其具体步骤如下：
1. *正向*扫描日志文件，建立两个队列
	- **重做队列(REDO-LIST)**：保存在故障发生前已经提交了的事务，这些事务同时有BEGIN TRANSACTION和COMMIT的记录；
	- **撤销队列(UNDO-LIST)**：保存在故障发生时尚未完成的事务，这些事务只有BEGIN TRANSACTION的记录。
1. 对UNDO-LIST里的事务进行UNDO处理，其实就是恢复事务故障的操作；
2. 对REDO-LIST中的每个事务日志记录中更新后的值写入数据库即可。

> [!example] 
> ![[Pasted image 20240516161113.png|175]]
> 上图例子中就应该REDO T1，UNDO T2
### 介质故障及其恢复
> [!definition] 介质故障
> 也叫**硬件故障**，外存中的数据部分或全部丢失，并影响所有相关事务。造成介质故障的原因：
> 1. 磁盘损坏
> 2. 磁头碰撞
> 3. 瞬时强磁场干扰

恢复系统故障需要DBA的介入，其遵循如下步骤：
1. 重装最新的后备数据库副本，使数据库恢复到最近一次转储时的一致性状态；
2. 对于静态转储的副本，重装后即为一致性状态；但对于动态转储的副本，则还需要装入转储时的日志文件副本，按照恢复系统故障的方法（REDO+UNDO）恢复后，才能将数据库恢复到一致性状态；
3. 依旧按照恢复系统故障的方法，装入转储结束后的日志文件副本。
## 具有检查点的恢复技术



补到4月1号的课

0513-2-0500